# Javaé¡¹ç›®è°ƒç”¨é“¾è·¯åˆ†æIDEAæ’ä»¶ - ä¼˜åŒ–æŠ€æœ¯æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

åŸºäºPSI APIå’Œå›¾æ•°æ®åº“æŠ€æœ¯ï¼Œæ„å»ºä¸€ä¸ªæ™ºèƒ½çš„Javaé¡¹ç›®è°ƒç”¨é“¾è·¯åˆ†ææ’ä»¶ï¼Œå¸®åŠ©å¼€å‘è€…ç†è§£å¤æ‚é¡¹ç›®çš„æ–¹æ³•è°ƒç”¨å…³ç³»ï¼Œå¿«é€Ÿå®šä½è°ƒç”¨è·¯å¾„ã€‚

---

## ğŸ—ï¸ æ€»ä½“æ¶æ„è®¾è®¡

### æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IntelliJ IDEA Plugin                                        â”‚
â”‚                                                             â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚   å±•ç°å±‚ (UI)    â”‚    â”‚        é€»è¾‘å±‚ (Core)             â”‚  â”‚
â”‚ â”‚ â€¢ Tool Window   â”‚â—„â”€â”€â–ºâ”‚ â€¢ PSIè§£æå™¨ (å¤šå±‚è§£æç­–ç•¥)        â”‚  â”‚
â”‚ â”‚ â€¢ è·¯å¾„å¯è§†åŒ–     â”‚    â”‚ â€¢ å¢é‡ç´¢å¼•å™¨ (æ€§èƒ½ä¼˜åŒ–)          â”‚  â”‚
â”‚ â”‚ â€¢ ç”¨æˆ·äº¤äº’      â”‚    â”‚ â€¢ ç¼“å­˜ç®¡ç†å™¨ (å¤šçº§ç¼“å­˜)          â”‚  â”‚
â”‚ â”‚ â€¢ å¼‚æ­¥UIæ›´æ–°    â”‚    â”‚ â€¢ æ•°æ®é€‚é…å™¨ (æ‰¹é‡å†™å…¥)          â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                    â–²                        â”‚
â”‚                                    â”‚ (å¼‚æ­¥é˜Ÿåˆ— + JDBC)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ•°æ®å±‚ (Neo4j Graph Database)                               â”‚
â”‚                                                             â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚   å›¾å­˜å‚¨å¼•æ“     â”‚    â”‚        æŸ¥è¯¢ä¼˜åŒ–å¼•æ“              â”‚  â”‚
â”‚ â”‚ â€¢ èŠ‚ç‚¹å­˜å‚¨      â”‚    â”‚ â€¢ CypheræŸ¥è¯¢ä¼˜åŒ–                â”‚  â”‚
â”‚ â”‚ â€¢ å…³ç³»å­˜å‚¨      â”‚    â”‚ â€¢ è·¯å¾„ç®—æ³• (BFS/DFS)           â”‚  â”‚
â”‚ â”‚ â€¢ ç´¢å¼•ç®¡ç†      â”‚    â”‚ â€¢ ç»“æœç¼“å­˜                     â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒè®¾è®¡åŸåˆ™

1. **åˆ†å±‚è§£è€¦**: å±•ç°å±‚ã€é€»è¾‘å±‚ã€æ•°æ®å±‚èŒè´£æ¸…æ™°
2. **å¼‚æ­¥ä¼˜å…ˆ**: é¿å…é˜»å¡IDEä¸»çº¿ç¨‹
3. **å¢é‡æ›´æ–°**: åªå¤„ç†å˜æ›´éƒ¨åˆ†ï¼Œæå‡æ€§èƒ½
4. **å¤šçº§ç¼“å­˜**: å†…å­˜ã€ç£ç›˜ã€æ•°æ®åº“ä¸‰çº§ç¼“å­˜ç­–ç•¥
5. **æ¸è¿›è§£æ**: ä»ç®€å•åˆ°å¤æ‚ï¼Œåˆ†å±‚å¤„ç†ä¸åŒç±»å‹çš„æ–¹æ³•è°ƒç”¨

---

## ğŸ”§ æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶

### 1. PSIè§£æå™¨ (åˆ†å±‚è§£æç­–ç•¥)

#### ç¬¬ä¸€å±‚ï¼šç›´æ¥æ–¹æ³•è°ƒç”¨è§£æ
```kotlin
class DirectCallAnalyzer {
    /**
     * è§£æç›´æ¥çš„æ–¹æ³•è°ƒç”¨
     * å¤„ç†: obj.method(), this.method(), super.method()
     */
    fun parseDirectCalls(method: PsiMethod): List<MethodCall> {
        val calls = mutableListOf<MethodCall>()
        
        method.accept(object : JavaRecursiveElementVisitor() {
            override fun visitMethodCallExpression(expression: PsiMethodCallExpression) {
                val resolvedMethod = expression.resolveMethod()
                if (resolvedMethod != null && isProjectMethod(resolvedMethod)) {
                    calls.add(MethodCall(
                        caller = method.getSignature(),
                        callee = resolvedMethod.getSignature(),
                        callType = CallType.DIRECT,
                        lineNumber = getLineNumber(expression),
                        confidence = 1.0
                    ))
                }
                super.visitMethodCallExpression(expression)
            }
        })
        
        return calls
    }
}
```

#### ç¬¬äºŒå±‚ï¼šæ¥å£å®ç°è§£æ
```kotlin
class InterfaceCallAnalyzer {
    /**
     * è§£ææ¥å£æ–¹æ³•è°ƒç”¨ï¼Œæ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„å®ç°
     */
    fun resolveInterfaceCalls(call: PsiMethodCallExpression): List<MethodCall> {
        val resolvedMethod = call.resolveMethod() ?: return emptyList()
        
        if (resolvedMethod.containingClass?.isInterface == true) {
            // æŸ¥æ‰¾æ‰€æœ‰å®ç°ç±»
            val implementations = findAllImplementations(resolvedMethod)
            return implementations.map { impl ->
                MethodCall(
                    caller = getCurrentMethod(call).getSignature(),
                    callee = impl.getSignature(),
                    callType = CallType.INTERFACE,
                    confidence = 0.8 // æ¥å£è°ƒç”¨çš„ç¡®å®šæ€§è¾ƒä½
                )
            }
        }
        
        return emptyList()
    }
    
    private fun findAllImplementations(interfaceMethod: PsiMethod): List<PsiMethod> {
        // ä½¿ç”¨IDEAçš„OverridingMethodsSearch API
        return OverridingMethodsSearch.search(interfaceMethod).findAll().toList()
    }
}
```

#### ç¬¬ä¸‰å±‚ï¼šSpringç‰¹æ€§è§£æ
```kotlin
class SpringCallAnalyzer {
    /**
     * è§£æSpringç‰¹æœ‰çš„è°ƒç”¨æ¨¡å¼
     * åŒ…æ‹¬: @Async, @EventListener, @Scheduledç­‰
     */
    fun resolveSpringCalls(method: PsiMethod): List<MethodCall> {
        val calls = mutableListOf<MethodCall>()
        
        // å¤„ç†@Asyncæ³¨è§£
        if (method.hasAnnotation("org.springframework.scheduling.annotation.Async")) {
            calls.add(MethodCall(
                caller = "Spring-AsyncExecutor",
                callee = method.getSignature(),
                callType = CallType.ASYNC,
                confidence = 0.9
            ))
        }
        
        // å¤„ç†@EventListeneræ³¨è§£
        if (method.hasAnnotation("org.springframework.context.event.EventListener")) {
            val eventType = getEventType(method)
            calls.addAll(findEventPublishers(eventType))
        }
        
        return calls
    }
}
```

### 2. å¢é‡ç´¢å¼•å™¨

```kotlin
class IncrementalIndexer(private val project: Project) {
    private val changeQueue = LinkedBlockingQueue<IndexTask>()
    private val indexExecutor = Executors.newFixedThreadPool(2)
    
    init {
        // ç›‘å¬æ–‡ä»¶å˜æ›´
        PsiManager.getInstance(project).addPsiTreeChangeListener(object : PsiTreeChangeAdapter() {
            override fun childAdded(event: PsiTreeChangeEvent) {
                handleFileChange(event.file)
            }
            
            override fun childRemoved(event: PsiTreeChangeEvent) {
                handleFileChange(event.file)
            }
            
            override fun childReplaced(event: PsiTreeChangeEvent) {
                handleFileChange(event.file)
            }
        })
    }
    
    private fun handleFileChange(file: PsiFile?) {
        if (file is PsiJavaFile) {
            val task = IndexTask(
                file = file,
                type = TaskType.INCREMENTAL_UPDATE,
                priority = Priority.HIGH
            )
            changeQueue.offer(task)
        }
    }
    
    fun processIndexQueue() {
        indexExecutor.submit {
            while (!Thread.currentThread().isInterrupted) {
                try {
                    val task = changeQueue.take()
                    processIndexTask(task)
                } catch (e: InterruptedException) {
                    Thread.currentThread().interrupt()
                    break
                }
            }
        }
    }
}
```

### 3. å¤šçº§ç¼“å­˜ç®¡ç†å™¨

```kotlin
class CallGraphCache {
    // L1: å†…å­˜ç¼“å­˜ (æœ€çƒ­æ•°æ®)
    private val memoryCache = ConcurrentHashMap<String, MethodNode>()
    
    // L2: ç£ç›˜ç¼“å­˜ (ä¸­ç­‰çƒ­åº¦æ•°æ®)
    private val diskCache = ChronicleMap
        .of(String::class.java, MethodNode::class.java)
        .entries(100_000)
        .create()
    
    // L3: æ•°æ®åº“ (å®Œæ•´æ•°æ®)
    private val neo4jService = Neo4jService()
    
    fun getMethodNode(signature: String): MethodNode? {
        // L1ç¼“å­˜æŸ¥æ‰¾
        memoryCache[signature]?.let { return it }
        
        // L2ç¼“å­˜æŸ¥æ‰¾
        diskCache[signature]?.let { node ->
            memoryCache[signature] = node // æå‡åˆ°L1
            return node
        }
        
        // L3æ•°æ®åº“æŸ¥æ‰¾
        return neo4jService.findMethodNode(signature)?.also { node ->
            diskCache[signature] = node // ç¼“å­˜åˆ°L2
            memoryCache[signature] = node // ç¼“å­˜åˆ°L1
        }
    }
    
    fun invalidateCache(signature: String) {
        memoryCache.remove(signature)
        diskCache.remove(signature)
        // æ•°æ®åº“ä¸­çš„æ•°æ®é€šè¿‡ç‰ˆæœ¬å·æœºåˆ¶å¤„ç†
    }
}
```

---

## ğŸ—„ï¸ æ•°æ®æ¨¡å‹è®¾è®¡

### Neo4jèŠ‚ç‚¹æ¨¡å‹
```cypher
// æ–¹æ³•èŠ‚ç‚¹
CREATE (m:Method {
    id: "com.example.UserService.getUser(Long)",
    className: "com.example.UserService",
    methodName: "getUser",
    signature: "getUser(Long)",
    returnType: "User",
    parameterTypes: ["Long"],
    modifiers: ["public"],
    annotations: ["@Transactional", "@Cacheable"],
    blockType: "Service",
    filePath: "/src/main/java/com/example/UserService.java",
    lineNumber: 45,
    complexity: 5, // åœˆå¤æ‚åº¦
    lastModified: 1703123456789,
    version: 1
})

// ç±»èŠ‚ç‚¹ (ç”¨äºèšåˆæŸ¥è¯¢)
CREATE (c:Class {
    id: "com.example.UserService",
    name: "UserService",
    packageName: "com.example",
    blockType: "Service",
    filePath: "/src/main/java/com/example/UserService.java",
    methodCount: 12
})

// åŒ…èŠ‚ç‚¹ (ç”¨äºæ¶æ„åˆ†æ)
CREATE (p:Package {
    id: "com.example",
    name: "example",
    classCount: 25,
    methodCount: 150
})
```

### å…³ç³»æ¨¡å‹
```cypher
// æ–¹æ³•è°ƒç”¨å…³ç³»
CREATE (caller:Method)-[:CALLS {
    callType: "DIRECT", // DIRECT, INTERFACE, REFLECTION, AOP, ASYNC
    lineNumber: 23,
    confidence: 0.95, // è°ƒç”¨ç¡®å®šæ€§è¯„åˆ† (0.0-1.0)
    frequency: 1, // é™æ€åˆ†ææ—¶ä¸º1ï¼Œè¿è¡Œæ—¶åˆ†æå¯ä»¥æ›´å¤š
    lastSeen: 1703123456789,
    context: "try-catch" // è°ƒç”¨ä¸Šä¸‹æ–‡ä¿¡æ¯
}]->(callee:Method)

// ç±»åŒ…å«å…³ç³»
CREATE (c:Class)-[:CONTAINS]->(m:Method)

// åŒ…åŒ…å«å…³ç³»
CREATE (p:Package)-[:CONTAINS]->(c:Class)

// ç»§æ‰¿å…³ç³»
CREATE (child:Class)-[:EXTENDS]->(parent:Class)

// å®ç°å…³ç³»
CREATE (impl:Class)-[:IMPLEMENTS]->(interface:Class)
```

---

## ğŸ” æ ¸å¿ƒç®—æ³•å®ç°

### 1. è·¯å¾„æŸ¥æ‰¾ç®—æ³•

#### æœ€çŸ­è·¯å¾„æŸ¥è¯¢
```cypher
// æŸ¥æ‰¾æœ€çŸ­è°ƒç”¨è·¯å¾„
MATCH (start:Method {id: $startMethodId}),
      (end:Method {id: $endMethodId})
MATCH p = shortestPath((start)-[:CALLS*1..15]->(end))
WHERE all(rel in relationships(p) WHERE rel.confidence > 0.5)
RETURN p,
       length(p) as pathLength,
       reduce(conf = 1.0, rel in relationships(p) | conf * rel.confidence) as totalConfidence
ORDER BY pathLength ASC, totalConfidence DESC
LIMIT 5
```

#### æ‰€æœ‰è·¯å¾„æŸ¥è¯¢ (å¸¦ä¼˜åŒ–)
```cypher
// æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½è·¯å¾„ (é™åˆ¶æ·±åº¦å’Œæ•°é‡)
MATCH (start:Method {id: $startMethodId}),
      (end:Method {id: $endMethodId})
MATCH p = (start)-[:CALLS*1..10]->(end)
WHERE all(n IN nodes(p) WHERE size([m IN nodes(p) WHERE m = n]) = 1) // é¿å…å¾ªç¯
  AND all(rel in relationships(p) WHERE rel.confidence > 0.3)
WITH p, 
     length(p) as pathLength,
     reduce(conf = 1.0, rel in relationships(p) | conf * rel.confidence) as totalConfidence
WHERE pathLength <= 8 // é™åˆ¶è·¯å¾„é•¿åº¦
RETURN p, pathLength, totalConfidence
ORDER BY totalConfidence DESC, pathLength ASC
LIMIT 50
```

### 2. çƒ­ç‚¹åˆ†æç®—æ³•
```cypher
// æŸ¥æ‰¾è°ƒç”¨çƒ­ç‚¹ (è¢«è°ƒç”¨æ¬¡æ•°æœ€å¤šçš„æ–¹æ³•)
MATCH (m:Method)<-[r:CALLS]-()
WITH m, count(r) as callCount, 
     collect(distinct r.callType) as callTypes
WHERE callCount > 5
RETURN m.id, m.className, m.methodName, 
       callCount, callTypes
ORDER BY callCount DESC
LIMIT 20
```

### 3. å½±å“åˆ†æç®—æ³•
```cypher
// åˆ†ææ–¹æ³•å˜æ›´çš„å½±å“èŒƒå›´
MATCH (changed:Method {id: $changedMethodId})
MATCH (affected:Method)-[:CALLS*1..5]->(changed)
WITH affected, 
     shortestPath((affected)-[:CALLS*]->(changed)) as path
RETURN affected.id, affected.className, affected.methodName,
       length(path) as distance,
       affected.blockType
ORDER BY distance ASC, affected.blockType
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. ç´¢å¼•ä¼˜åŒ–
```cypher
// Neo4jç´¢å¼•åˆ›å»º
CREATE INDEX method_id_index FOR (m:Method) ON (m.id);
CREATE INDEX method_class_index FOR (m:Method) ON (m.className);
CREATE INDEX method_block_type_index FOR (m:Method) ON (m.blockType);
CREATE INDEX calls_confidence_index FOR ()-[r:CALLS]-() ON (r.confidence);
```

### 2. æ‰¹é‡å†™å…¥ä¼˜åŒ–
```kotlin
class BatchNeo4jWriter(private val driver: Driver) {
    private val batchSize = 1000
    private val nodeBuffer = mutableListOf<MethodNode>()
    private val relationshipBuffer = mutableListOf<MethodCall>()
    
    fun addNode(node: MethodNode) {
        nodeBuffer.add(node)
        if (nodeBuffer.size >= batchSize) {
            flushNodes()
        }
    }
    
    private fun flushNodes() {
        driver.session().use { session ->
            session.writeTransaction { tx ->
                val query = """
                    UNWIND ${'$'}nodes AS node
                    MERGE (m:Method {id: node.id})
                    SET m += node.properties
                """.trimIndent()
                
                tx.run(query, mapOf("nodes" to nodeBuffer.map { it.toMap() }))
            }
        }
        nodeBuffer.clear()
    }
}
```

### 3. æŸ¥è¯¢ç»“æœç¼“å­˜
```kotlin
class QueryResultCache {
    private val cache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(30, TimeUnit.MINUTES)
        .build<String, List<CallPath>>()
    
    fun getOrCompute(query: String, computer: () -> List<CallPath>): List<CallPath> {
        return cache.get(query) { computer() }
    }
}
```

---

## ğŸ¨ ç”¨æˆ·ç•Œé¢è®¾è®¡

### Tool Windowå¸ƒå±€
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è°ƒç”¨é“¾è·¯åˆ†æ                                    [âš™ï¸][ğŸ“Š][â“] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æœç´¢åŒºåŸŸ                                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ èµ·å§‹æ–¹æ³•         â”‚  â”‚ ç›®æ ‡æ–¹æ³•         â”‚  â”‚ [ğŸ”æœç´¢] â”‚   â”‚
â”‚ â”‚ [è‡ªåŠ¨è¡¥å…¨è¾“å…¥æ¡†] â”‚  â”‚ [è‡ªåŠ¨è¡¥å…¨è¾“å…¥æ¡†] â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                         â”‚
â”‚ é€‰é¡¹: â–¡ æœ€çŸ­è·¯å¾„  â–¡ æ‰€æœ‰è·¯å¾„  â–¡ åŒ…å«æ¥å£è°ƒç”¨  â–¡ åŒ…å«å¼‚æ­¥è°ƒç”¨ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç»“æœåŒºåŸŸ                                    [ğŸ“‹][ğŸ“Š][ğŸ”„] â”‚
â”‚                                                         â”‚
â”‚ ğŸ“Š è·¯å¾„ç»Ÿè®¡: æ‰¾åˆ° 3 æ¡è·¯å¾„, æœ€çŸ­ 4 å±‚, å¹³å‡ç½®ä¿¡åº¦ 0.85    â”‚
â”‚                                                         â”‚
â”‚ ğŸ›¤ï¸ è·¯å¾„ 1 (æœ€çŸ­è·¯å¾„, ç½®ä¿¡åº¦: 0.92)                      â”‚
â”‚   UserController.getUser() [Controller]                â”‚
â”‚   â”œâ”€ UserService.findById() [Service]                  â”‚
â”‚   â”œâ”€ UserRepository.findById() [Repository]            â”‚
â”‚   â””â”€ JpaRepository.findById() [Framework]              â”‚
â”‚                                                         â”‚
â”‚ ğŸ›¤ï¸ è·¯å¾„ 2 (ç½®ä¿¡åº¦: 0.78)                               â”‚
â”‚   UserController.getUser() [Controller]                â”‚
â”‚   â”œâ”€ UserService.getUserWithCache() [Service]          â”‚
â”‚   â”œâ”€ CacheService.get() [Service]                      â”‚
â”‚   â”œâ”€ UserRepository.findById() [Repository]            â”‚
â”‚   â””â”€ JpaRepository.findById() [Framework]              â”‚
â”‚                                                         â”‚
â”‚ ğŸ›¤ï¸ è·¯å¾„ 3 (å¼‚æ­¥è·¯å¾„, ç½®ä¿¡åº¦: 0.65)                      â”‚
â”‚   UserController.getUser() [Controller]                â”‚
â”‚   â”œâ”€ AsyncUserService.findByIdAsync() [Service]        â”‚
â”‚   â””â”€ CompletableFuture.supplyAsync() [Framework]       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### äº¤äº’åŠŸèƒ½
- **åŒå‡»æ–¹æ³•**: è·³è½¬åˆ°æºä»£ç 
- **å³é”®èœå•**: æŸ¥çœ‹æ–¹æ³•è¯¦æƒ…ã€æ·»åŠ åˆ°æ”¶è—ã€å¯¼å‡ºè·¯å¾„
- **è¿‡æ»¤å™¨**: æŒ‰åŒ…åã€ç±»å‹ã€ç½®ä¿¡åº¦è¿‡æ»¤
- **å¯è§†åŒ–**: å›¾å½¢åŒ–æ˜¾ç¤ºè°ƒç”¨è·¯å¾„

---

## ğŸ”§ é…ç½®ç®¡ç†

### æ’ä»¶é…ç½®ç•Œé¢
```kotlin
class CallGraphConfigurable : Configurable {
    private lateinit var neo4jUrlField: JTextField
    private lateinit var maxDepthSpinner: JSpinner
    private lateinit var confidenceThresholdSlider: JSlider
    private lateinit var enableSpringAnalysisCheckbox: JCheckBox
    
    override fun createComponent(): JComponent {
        return panel {
            group("æ•°æ®åº“é…ç½®") {
                row("Neo4j URL:") { neo4jUrlField() }
                row("ç”¨æˆ·å:") { textField() }
                row("å¯†ç :") { passwordField() }
            }
            
            group("åˆ†æé…ç½®") {
                row("æœ€å¤§æœç´¢æ·±åº¦:") { 
                    maxDepthSpinner = spinner(1..20, 10)
                }
                row("æœ€ä½ç½®ä¿¡åº¦:") {
                    confidenceThresholdSlider = slider(0, 100, 50)
                }
                row("å¯ç”¨Springåˆ†æ:") {
                    enableSpringAnalysisCheckbox = checkBox()
                }
            }
            
            group("æ€§èƒ½é…ç½®") {
                row("æ‰¹å¤„ç†å¤§å°:") { spinner(100..5000, 1000) }
                row("ç¼“å­˜å¤§å°:") { spinner(1000..50000, 10000) }
                row("ç´¢å¼•çº¿ç¨‹æ•°:") { spinner(1..8, 2) }
            }
        }
    }
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
```kotlin
class DirectCallAnalyzerTest {
    @Test
    fun `should parse direct method calls correctly`() {
        val testCode = """
            class TestService {
                public void methodA() {
                    methodB();
                    this.methodC();
                    otherService.methodD();
                }
                
                private void methodB() {}
                private void methodC() {}
            }
        """.trimIndent()
        
        val analyzer = DirectCallAnalyzer()
        val calls = analyzer.parseDirectCalls(getMethodFromCode(testCode, "methodA"))
        
        assertThat(calls).hasSize(3)
        assertThat(calls.map { it.callee }).containsExactly(
            "TestService.methodB()",
            "TestService.methodC()",
            "OtherService.methodD()"
        )
    }
}
```

### é›†æˆæµ‹è¯•
```kotlin
class CallGraphIntegrationTest {
    @Test
    fun `should build complete call graph for sample project`() {
        val project = loadTestProject("sample-spring-boot-project")
        val builder = CallGraphBuilder(project)
        
        val graph = builder.buildGraph()
        
        // éªŒè¯å›¾çš„å®Œæ•´æ€§
        assertThat(graph.nodeCount).isGreaterThan(100)
        assertThat(graph.edgeCount).isGreaterThan(200)
        
        // éªŒè¯ç‰¹å®šè·¯å¾„
        val paths = graph.findPaths(
            "UserController.getUser(Long)",
            "UserRepository.findById(Long)"
        )
        assertThat(paths).isNotEmpty()
    }
}
```

### æ€§èƒ½æµ‹è¯•
```kotlin
class PerformanceTest {
    @Test
    fun `should index large project within acceptable time`() {
        val largeProject = loadTestProject("large-project-1000-classes")
        val indexer = IncrementalIndexer(largeProject)
        
        val startTime = System.currentTimeMillis()
        indexer.buildFullIndex()
        val duration = System.currentTimeMillis() - startTime
        
        // 1000ä¸ªç±»åº”è¯¥åœ¨30ç§’å†…å®Œæˆç´¢å¼•
        assertThat(duration).isLessThan(30_000)
    }
}
```

---

## ğŸ“ˆ ç›‘æ§å’Œè¯Šæ–­

### æ€§èƒ½ç›‘æ§
```kotlin
class CallGraphMetrics {
    private val indexingTime = Timer.builder("callgraph.indexing.time").register(meterRegistry)
    private val queryTime = Timer.builder("callgraph.query.time").register(meterRegistry)
    private val cacheHitRate = Gauge.builder("callgraph.cache.hit.rate").register(meterRegistry)
    
    fun recordIndexingTime(duration: Duration) {
        indexingTime.record(duration)
    }
    
    fun recordQueryTime(duration: Duration) {
        queryTime.record(duration)
    }
}
```

### è¯Šæ–­å·¥å…·
```kotlin
class CallGraphDiagnostics {
    fun generateHealthReport(): HealthReport {
        return HealthReport(
            databaseConnected = neo4jService.isConnected(),
            indexStatus = indexer.getStatus(),
            cacheStatistics = cache.getStatistics(),
            memoryUsage = getMemoryUsage(),
            lastIndexTime = indexer.getLastIndexTime()
        )
    }
}
```

---

## ğŸš€ æ‰©å±•åŠŸèƒ½è§„åˆ’

### 1. ä»£ç å½±å“åˆ†æ
- åˆ†ææ–¹æ³•å˜æ›´å¯¹æ•´ä¸ªç³»ç»Ÿçš„å½±å“èŒƒå›´
- ç”Ÿæˆå½±å“åˆ†ææŠ¥å‘Š

### 2. æ¶æ„å¯è§†åŒ–
- ç”Ÿæˆç³»ç»Ÿæ¶æ„å›¾
- åŒ…ä¾èµ–å…³ç³»å›¾
- è°ƒç”¨çƒ­åŠ›å›¾

### 3. ä»£ç è´¨é‡åˆ†æ
- è¯†åˆ«å¾ªç¯ä¾èµ–
- æ£€æµ‹è¿‡åº¦è€¦åˆ
- åˆ†ææ–¹æ³•å¤æ‚åº¦

### 4. å›¢é˜Ÿåä½œåŠŸèƒ½
- å¯¼å‡ºè°ƒç”¨é“¾è·¯æŠ¥å‘Š
- åˆ†äº«åˆ†æç»“æœ
- å›¢é˜Ÿé…ç½®åŒæ­¥

---

## ğŸ“š æŠ€æœ¯æ ˆæ€»ç»“

- **æ ¸å¿ƒæ¡†æ¶**: IntelliJ Platform SDK
- **ä»£ç åˆ†æ**: PSI API
- **å›¾æ•°æ®åº“**: Neo4j + Cypher
- **ç¼“å­˜**: Caffeine + Chronicle Map
- **å¼‚æ­¥å¤„ç†**: Java CompletableFuture + ExecutorService
- **UIæ¡†æ¶**: Swing + IntelliJ UI DSL
- **æµ‹è¯•æ¡†æ¶**: JUnit 5 + AssertJ + Mockito
- **ç›‘æ§**: Micrometer
- **æ„å»ºå·¥å…·**: Gradle + Kotlin DSL

è¿™ä¸ªä¼˜åŒ–åçš„æŠ€æœ¯æ–¹æ¡ˆæä¾›äº†æ›´å®Œæ•´çš„æ¶æ„è®¾è®¡ã€æ›´è¯¦ç»†çš„å®ç°æ–¹æ¡ˆå’Œæ›´å…¨é¢çš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œä¸ºé¡¹ç›®çš„æˆåŠŸå®æ–½å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚