# **æŠ€æœ¯æ–¹æ¡ˆ V5.1ï¼šä¼ä¸šçº§AIä»£ç è¯„å®¡å¼•æ“ (å®Œæ•´èåˆç‰ˆ)**

---

## ğŸ¯ **1. æ ¸å¿ƒæ„¿æ™¯ä¸è®¾è®¡ç†å¿µ**

æœ¬æ–¹æ¡ˆæ—¨åœ¨æ„å»ºä¸€ä¸ª**é«˜æ€§èƒ½ã€é«˜å¯ç”¨ã€å¯æ‰©å±•çš„ä¼ä¸šçº§AIä»£ç è¯„å®¡å¼•æ“**ï¼Œé€šè¿‡**åŒå›¾è°±æ¶æ„**ã€**åŒæµæ™ºèƒ½åˆ†æ**å’Œ**å¤šAIä¾›åº”å•†æ”¯æŒ**ï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›ç¨³å®šå¯é ä¸”æ·±åº¦ä¸“ä¸šçš„è‡ªåŠ¨åŒ–ä»£ç è¯„å®¡æœåŠ¡ã€‚

### **æ ¸å¿ƒç›®æ ‡**
æ¨¡æ‹Ÿä¸€ä¸ªèµ„æ·±æ¶æ„å¸ˆçš„è¯„å®¡è¿‡ç¨‹ï¼Œå¯¹ä¸€ä¸ªå®Œæ•´çš„Merge Request (MR)æˆ–ç‰¹æ€§åˆ†æ”¯è¿›è¡Œå…¨é¢åˆ†æï¼Œå¹¶å›ç­”ï¼š

1. **åŠŸ (Merit)**: è¿™æ¬¡å˜æ›´å®ç°äº†ä»€ä¹ˆæœ‰ä»·å€¼çš„åŠŸèƒ½ï¼Ÿ(æ„å›¾åˆ†æ)
2. **è¿‡ (Flaw)**: è¿™æ¬¡å˜æ›´å¼•å…¥äº†å“ªäº›æŠ€æœ¯é£é™©æˆ–åå‘³é“ï¼Ÿ(å½±å“åˆ†æ)
3. **ç­– (Suggestion)**: å¦‚ä½•åœ¨ä¿ç•™å…¶åŠŸèƒ½ä»·å€¼çš„åŒæ—¶ï¼Œä¿®å¤å…¶æŠ€æœ¯ç¼ºé™·ï¼Ÿ(ç»¼åˆå»ºè®®)

### **è®¾è®¡åŸåˆ™**
1. **æ€§èƒ½ä¼˜å…ˆ**: å¼‚æ­¥å¤„ç† + æ™ºèƒ½ç¼“å­˜ï¼Œç¡®ä¿å¤§å‹é¡¹ç›®ä¹Ÿèƒ½åœ¨åˆç†æ—¶é—´å†…å®Œæˆåˆ†æ
2. **å¯é æ€§ä¿éšœ**: å¤šé‡fallbackæœºåˆ¶ï¼Œç¡®ä¿æœåŠ¡å¯ç”¨æ€§ > 99.5%
3. **å¯æ‰©å±•æ€§**: åŒå›¾è°±æ¶æ„æ”¯æŒä»å°å‹åˆ°è¶…å¤§å‹é¡¹ç›®çš„æ— ç¼æ‰©å±•
4. **é€æ˜æ€§**: é‡åŒ–çš„è¯„åˆ†ç®—æ³•ï¼Œè®©AIå†³ç­–è¿‡ç¨‹å¯è§£é‡Šã€å¯è°ƒä¼˜

---

## âš™ï¸ **2. æ ¸å¿ƒç”¨æˆ·å·¥ä½œæµ**

1. **è§¦å‘**: å¼€å‘è€…åœ¨IDEä¸­é€šè¿‡å³é”®èœå•æˆ–å·¥å…·æ æŒ‰é’®ä¸»åŠ¨è§¦å‘åˆ†æã€‚æ’ä»¶æä¾›å¤šç§çµæ´»çš„åˆ†ææ¨¡å¼ï¼š
   - **åˆ†æ”¯å¯¹æ¯”æ¨¡å¼**: é€‰æ‹©è¦å¯¹æ¯”çš„**æºåˆ†æ”¯**å’Œ**ç›®æ ‡åˆ†æ”¯**ï¼ˆæ ‡å‡†MR/PRè¯„å®¡ï¼‰
   - **Commité›†åˆæ¨¡å¼**: åœ¨Gitæ—¥å¿—ä¸­ï¼Œæ‰‹åŠ¨é€‰æ‹©å½“å‰åˆ†æ”¯ä¸Šçš„ä¸€ç³»åˆ—è¿ç»­æˆ–ä¸è¿ç»­çš„Commitsè¿›è¡Œåˆ†æ
   - **(è¿œæœŸè§„åˆ’) URLæ¨¡å¼**: ç›´æ¥ç²˜è´´ä¸€ä¸ªGitHub/GitLabçš„Merge/Pull Requesté“¾æ¥è¿›è¡Œåˆ†æ

2. **é¢„å¤„ç†ä¸åŠ æƒ**: æ’ä»¶åœ¨åå°å¯åŠ¨**"åŒæµåˆ†æå¼•æ“"**ï¼Œå¯¹ä¸¤ä¸ªåˆ†æ”¯é—´çš„ä»£ç å·®å¼‚è¿›è¡Œæ‰«æï¼Œå¹¶ä»**"æ„å›¾"**å’Œ**"é£é™©"**ä¸¤ä¸ªç»´åº¦ï¼Œå¯¹æ‰€æœ‰ç›¸å…³çš„è°ƒç”¨é“¾è·¯å’Œä»£ç å˜æ›´è¿›è¡ŒåŠ æƒè¯„åˆ†

3. **ä¸‰é˜¶æ®µAIåˆ†æ**: 
   - **é˜¶æ®µä¸€ (å¿«é€Ÿç­›é€‰)**: ä½¿ç”¨è½»é‡çº§ã€é«˜é€Ÿåº¦çš„AIæ¨¡å‹ï¼Œæ ¹æ®é¢„å¤„ç†é˜¶æ®µçš„æƒé‡ï¼Œç­›é€‰å‡º"é»„é‡‘é“¾è·¯"å’Œ"é«˜å±é“¾è·¯"
   - **é˜¶æ®µäºŒ (æ·±åº¦ç ”åˆ¤)**: å°†ç­›é€‰å‡ºçš„ã€å¸¦æœ‰æ˜ç¡®ä¸Šä¸‹æ–‡ï¼ˆæ„å›¾/é£é™©ï¼‰çš„å…³é”®ä¿¡æ¯ï¼Œæäº¤ç»™å¼ºå¤§çš„ä¸»åˆ†æAIæ¨¡å‹ï¼Œè¿›è¡Œæ·±åº¦ã€è¾©è¯çš„åˆ†æ
   - **é˜¶æ®µä¸‰ (å¼‚æ­¥å¯è§†åŒ–)**: å°†åˆ†æç»“æœåŒæ­¥åˆ°Neo4jï¼Œæä¾›é¡¹ç›®å…¨æ™¯å¯è§†åŒ–

4. **æŠ¥å‘Šå‘ˆç°**: åœ¨IDEçš„ä¸“å±å·¥å…·çª—å£ä¸­ï¼Œå±•ç¤ºä¸€ä»½ç»“æ„åŒ–ã€å±‚æ¬¡åˆ†æ˜çš„**"AIä»£ç è¯„å®¡æŠ¥å‘Š"**ï¼Œæ¸…æ™°åœ°åˆ—å‡ºå¯¹æ„å›¾ã€é£é™©çš„åˆ†æä»¥åŠæœ€ç»ˆçš„ç»¼åˆå»ºè®®

---

## ğŸ—ï¸ **3. ç³»ç»Ÿæ¶æ„è®¾è®¡ (V5.1å®Œæ•´ç‰ˆ)**

### **3.1 æ•´ä½“æ¶æ„è§†å›¾**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              IntelliJ IDEA Plugin Framework                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å±•ç°å±‚ (UI Layer)                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   åˆ†æ”¯é€‰æ‹©å¯¹è¯æ¡†         â”‚   â”‚        AIä»£ç è¯„å®¡æŠ¥å‘Š (Tool Window)              â”‚ â”‚
â”‚  â”‚   - æº/ç›®æ ‡åˆ†æ”¯          â”‚   â”‚        - Part 1: æ„å›¾åˆ†æ (Golden Path)         â”‚ â”‚
â”‚  â”‚   - Commité›†åˆé€‰æ‹©       â”‚   â”‚        - Part 2: é£é™©åˆ†æ (Risk Path)           â”‚ â”‚
â”‚  â”‚   - åˆ†ææ¨¡å¼é…ç½®         â”‚   â”‚        - Part 3: ç»¼åˆè¯„å®¡ (Final Verdict)      â”‚ â”‚
â”‚  â”‚   - è§¦å‘åˆ†ææŒ‰é’®         â”‚   â”‚        - Part 4: Neo4jå¯è§†åŒ–é“¾æ¥              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  é€»è¾‘å±‚ (Core Layer) - åŒæµæ™ºèƒ½åˆ†æå¼•æ“                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                       æ™ºèƒ½é¢„å¤„ç†å™¨ (åŒæƒé‡ç³»ç»Ÿ)                                 â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚   æµA: æ„å›¾æƒé‡è®¡ç®—å™¨       â”‚    â”‚   æµB: é£é™©æƒé‡è®¡ç®—å™¨                â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   - ä¸šåŠ¡ä»·å€¼åˆ†æ           â”‚    â”‚   - æ¶æ„è¿è§„æ£€æµ‹                    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   - å®ç°å®Œæ•´æ€§è¯„ä¼°         â”‚    â”‚   - çˆ†ç‚¸åŠå¾„è®¡ç®—                    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   - ä»£ç è´¨é‡è¯„åˆ†           â”‚    â”‚   - æ•æ„Ÿæ³¨è§£è¯†åˆ«                    â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                       ä¸‰é˜¶æ®µå¤§æ¨¡å‹è°ƒç”¨ç®¡ç†å™¨                                    â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚   é˜¶æ®µä¸€: é¢„åˆ†æ (å°æ¨¡å‹)   â”‚  â”‚   é˜¶æ®µäºŒ: æ·±åº¦åˆ†æ (å¤§æ¨¡å‹)             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   - å¿«é€Ÿé“¾è·¯ç­›é€‰           â”‚  â”‚   - æ„å›¾æ·±åº¦è§£æ                       â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   - åŸºç¡€é£é™©è¯†åˆ«           â”‚  â”‚   - é£é™©å½±å“è¯„ä¼°                       â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   - æƒé‡éªŒè¯              â”‚  â”‚   - ç»¼åˆå»ºè®®ç”Ÿæˆ                       â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚   é˜¶æ®µä¸‰: å¼‚æ­¥å¯è§†åŒ– (Neo4jåŒæ­¥)                                        â”‚   â”‚ â”‚
â”‚  â”‚  â”‚   - é¡¹ç›®å…¨æ™¯å›¾è°±æ„å»º     - å†å²æ¼”è¿›åˆ†æ     - å›¢é˜Ÿåä½œæ¨¡å¼            â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   ä¸Šä¸‹æ–‡èšåˆå™¨           â”‚ â”‚   PSIè§£æå¼•æ“   â”‚ â”‚  åŒå›¾è°±å¼•æ“     â”‚ â”‚  ç¼“å­˜ç³»ç»Ÿâ”‚ â”‚
â”‚  â”‚   - Git Diff/Log åˆ†æ   â”‚ â”‚   - ASTéå†     â”‚ â”‚   - TinkerGraph â”‚ â”‚  - ä¸‰çº§  â”‚ â”‚
â”‚  â”‚   - æµ‹è¯•ç”¨ä¾‹å…³è”        â”‚ â”‚   - æ³¨è§£è¯†åˆ«    â”‚ â”‚   - Neo4j       â”‚ â”‚    ç¼“å­˜  â”‚ â”‚
â”‚  â”‚   - å®Œæ•´æ–¹æ³•ä½“æå–      â”‚ â”‚   - ä¾èµ–è§£æ    â”‚ â”‚   - å¢é‡æ›´æ–°    â”‚ â”‚  - çƒ­ç‚¹  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æœåŠ¡å±‚ (Service Layer) - å¤šAIä¾›åº”å•†æ”¯æŒ                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                         AIæœåŠ¡ç¼–æ’å™¨ (AI Orchestrator)                        â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚   OpenAI    â”‚ â”‚  Anthropic  â”‚ â”‚   Google    â”‚ â”‚    Ollama   â”‚ â”‚ HuggingF â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   GPT-4o    â”‚ â”‚  Claude-3   â”‚ â”‚   Gemini    â”‚ â”‚   Llama3    â”‚ â”‚   Face   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  GPT-3.5    â”‚ â”‚  Opus/Son   â”‚ â”‚  Pro/Flash  â”‚ â”‚   Qwen2     â”‚ â”‚  å¼€æºæ¨¡å‹â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚   æ™ºèƒ½è·¯ç”± + è´Ÿè½½å‡è¡¡ + ä¸‰çº§Fallbackæœºåˆ¶                                 â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ•°æ®å±‚ (Data Layer) - åŒå›¾è°±å­˜å‚¨                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  æœ¬åœ°è½»é‡å›¾è°±    â”‚ â”‚   Neo4jå¯è§†åŒ–   â”‚ â”‚    æ’ä»¶é…ç½®      â”‚ â”‚   ç¼“å­˜å­˜å‚¨      â”‚ â”‚
â”‚  â”‚  - project.tg   â”‚ â”‚   - å…¨æ™¯è§†å›¾    â”‚ â”‚    - AI Keys     â”‚ â”‚   - æ–¹æ³•ç¼“å­˜    â”‚ â”‚
â”‚  â”‚  - çƒ­ç‚¹è·¯å¾„     â”‚ â”‚   - å†å²è¿½è¸ª    â”‚ â”‚    - æƒé‡é…ç½®    â”‚ â”‚   - è·¯å¾„ç¼“å­˜    â”‚ â”‚
â”‚  â”‚  - å¢é‡ç´¢å¼•     â”‚ â”‚   - å›¢é˜Ÿåä½œ    â”‚ â”‚    - é˜ˆå€¼è®¾å®š    â”‚ â”‚   - AIç»“æœç¼“å­˜  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **3.2 åŒå›¾è°±æ¶æ„è¯¦è§£**

#### **æœ¬åœ°è½»é‡çº§å›¾è°± (ä¸šåŠ¡æ ¸å¿ƒ)**
- **å›¾å¼•æ“**: Apache TinkerGraph (åµŒå…¥å¼ï¼Œæ— å¤–éƒ¨ä¾èµ–)
- **ç”¨é€”**: å®æ—¶ä»£ç åˆ†æï¼Œæ¯«ç§’çº§å“åº”
- **å­˜å‚¨**: å†…å­˜ + ç£ç›˜æŒä¹…åŒ– + å¢é‡æ›´æ–°

#### **Neo4jå¯è§†åŒ–å›¾è°± (å¼‚æ­¥å±•ç¤º)**
- **ç”¨é€”**: é¡¹ç›®å…¨æ™¯æ´å¯Ÿï¼Œå†å²æ¼”è¿›åˆ†æ
- **æ›´æ–°**: å¼‚æ­¥å¤„ç†ï¼Œä¸å½±å“ä¸»æµç¨‹æ€§èƒ½
- **åŠŸèƒ½**: æ¶æ„ä¾èµ–å›¾ã€é£é™©çƒ­åŠ›å›¾ã€è´¨é‡è¶‹åŠ¿åˆ†æ

---

## ğŸ’¾ **4. æ•°æ®æ¨¡å‹ä¸å›¾å¼•æ“è®¾è®¡**

### **4.1 èŠ‚ç‚¹IDè§„èŒƒ**
- **æ–¹æ³•èŠ‚ç‚¹ID**: `{packageName}.{className}#{methodName}({paramTypes})`
  - *ç¤ºä¾‹*: `com.example.service.UserService#getUser(java.lang.String)`
- **ç±»èŠ‚ç‚¹ID**: `{packageName}.{className}`
  - *ç¤ºä¾‹*: `com.example.service.UserService`

### **4.2 æ ¸å¿ƒæ•°æ®æ¨¡å‹ (è¯¦ç»†å®šä¹‰)**

#### **èŠ‚ç‚¹ç±»å‹ (Node)**
```java
// å®Œæ•´æ–¹æ³•èŠ‚ç‚¹æ¨¡å‹
MethodNode {
    String id; // å”¯ä¸€æ ‡è¯†
    String methodName;
    String signature; // å®Œæ•´æ–¹æ³•ç­¾å
    String returnType;
    List<String> paramTypes;
    String blockType; // CONTROLLER, SERVICE, MAPPER, REPOSITORY, UTIL
    boolean isInterface;
    List<String> annotations;
    String filePath; // ç»å¯¹è·¯å¾„
    int lineNumber;
    int startLineNumber;
    int endLineNumber;
    
    // V5.1 æ–°å¢æ€§èƒ½ç›¸å…³å­—æ®µ
    int cyclomaticComplexity; // åœˆå¤æ‚åº¦
    int linesOfCode; // ä»£ç è¡Œæ•°
    int inDegree; // è¢«è°ƒç”¨æ¬¡æ•°
    int outDegree; // è°ƒç”¨ä»–äººæ¬¡æ•°
    double riskScore; // é¢„è®¡ç®—é£é™©åˆ†æ•°
    boolean hasTests; // æ˜¯å¦æœ‰æµ‹è¯•
    long lastModified; // æœ€åä¿®æ”¹æ—¶é—´
}

// å®Œæ•´ç±»èŠ‚ç‚¹æ¨¡å‹
ClassNode {
    String id; // å”¯ä¸€æ ‡è¯†
    String className;
    String packageName;
    String blockType;
    boolean isInterface;
    boolean isAbstract;
    String filePath;
    List<String> implementedInterfaces;
    String superClass;
    List<String> annotations;
    
    // V5.1 æ–°å¢å­—æ®µ
    int methodCount; // æ–¹æ³•æ€»æ•°
    int fieldCount; // å­—æ®µæ€»æ•°
    double cohesion; // å†…èšåº¦
    double coupling; // è€¦åˆåº¦
    List<String> designPatterns; // è¯†åˆ«çš„è®¾è®¡æ¨¡å¼
}
```

#### **å…³ç³»ç±»å‹ (Edge)**
```java
// è°ƒç”¨å…³ç³» (å¢å¼ºç‰ˆ)
CallsEdge {
    MethodNode caller;
    MethodNode callee;
    String callType; // DIRECT, INTERFACE, REFLECTION, LAMBDA
    int lineNumber; // è°ƒç”¨å‘ç”Ÿè¡Œå·
    int frequency; // è°ƒç”¨é¢‘ç‡ (é™æ€åˆ†æä¼°ç®—)
    boolean isConditional; // æ˜¯å¦æ¡ä»¶è°ƒç”¨
    String context; // è°ƒç”¨ä¸Šä¸‹æ–‡ (try/catch/if/loop)
    
    // V5.1 æ–°å¢
    double riskWeight; // è¯¥è°ƒç”¨çš„é£é™©æƒé‡
    double intentWeight; // è¯¥è°ƒç”¨çš„æ„å›¾æƒé‡
    boolean isNewInMR; // æ˜¯å¦ä¸ºMRæ–°å¢è°ƒç”¨
    boolean isModifiedInMR; // æ˜¯å¦ä¸ºMRä¿®æ”¹è°ƒç”¨
}

// å®ç°å…³ç³» (å¢å¼ºç‰ˆ)
ImplementsEdge {
    MethodNode interfaceMethod;
    MethodNode implementationMethod;
    boolean isOverride;
    
    // V5.1 æ–°å¢
    double implementationQuality; // å®ç°è´¨é‡è¯„åˆ†
    boolean followsContract; // æ˜¯å¦éµå¾ªæ¥å£å¥‘çº¦
}

// æ•°æ®æµå…³ç³» (V5.1 æ–°å¢)
DataFlowEdge {
    MethodNode source;
    MethodNode target;
    String dataType; // ä¼ é€’çš„æ•°æ®ç±»å‹
    String flowType; // PARAMETER, RETURN_VALUE, FIELD_ACCESS
    boolean isSensitive; // æ˜¯å¦ä¸ºæ•æ„Ÿæ•°æ®
}
```

### **4.3 åµŒå…¥å¼å›¾å¼•æ“å·¥ä½œæµ**

1. **é¦–æ¬¡ç´¢å¼•**: æ’ä»¶é¦–æ¬¡å¯¹é¡¹ç›®è¿›è¡Œå…¨é‡æ‰«æï¼Œä½¿ç”¨PSIè§£æå™¨æ„å»ºä¸€ä¸ªå®Œæ•´çš„è°ƒç”¨å…³ç³»å›¾ï¼Œå­˜å‚¨åœ¨å†…å­˜çš„`TinkerGraph`å¯¹è±¡ä¸­

2. **æŒä¹…åŒ–**: å°†æ„å»ºå¥½çš„å›¾æ¨¡å‹åºåˆ—åŒ–æˆä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆå¦‚ `project.tg`ï¼‰ï¼Œå­˜å‚¨åœ¨é¡¹ç›®çš„`.idea`æˆ–`.autocr`ç›®å½•ä¸‹

3. **å¢é‡æ›´æ–°**: ç›‘å¬æ–‡ä»¶å˜æ›´ï¼Œä»…é‡æ–°è§£æè¯¥æ–‡ä»¶å¹¶æ›´æ–°å†…å­˜å›¾æ¨¡å‹

4. **çƒ­ç‚¹ä¼˜åŒ–**: ç»´æŠ¤ä¸€ä¸ªçƒ­ç‚¹è·¯å¾„ç¼“å­˜ï¼Œä¼˜å…ˆç¼“å­˜æœ€å¸¸åˆ†æçš„è°ƒç”¨é“¾è·¯

---

## ğŸ”§ **5. ä¸Šä¸‹æ–‡èšåˆå™¨ (è¯¦ç»†è®¾è®¡)**

### **5.1 Gitå·®å¼‚åˆ†æå™¨**
```kotlin
class GitDiffAnalyzer {
    
    fun analyzeBranchDifferences(sourceBranch: String, targetBranch: String): GitDiffContext {
        // è·å–æ–‡ä»¶å˜æ›´åˆ—è¡¨
        val changedFiles = executeGitCommand("git diff --name-status $targetBranch..$sourceBranch")
        
        // è·å–æ¯ä¸ªæ–‡ä»¶çš„å…·ä½“å˜æ›´
        val fileChanges = changedFiles.map { file ->
            val diff = executeGitCommand("git diff $targetBranch..$sourceBranch -- ${file.path}")
            analyzeFileDiff(file, diff)
        }
        
        return GitDiffContext(
            sourceBranch = sourceBranch,
            targetBranch = targetBranch,
            changedFiles = changedFiles,
            fileChanges = fileChanges,
            addedLines = fileChanges.sumOf { it.addedLines },
            deletedLines = fileChanges.sumOf { it.deletedLines }
        )
    }
    
    private fun analyzeFileDiff(file: ChangedFile, diff: String): FileChange {
        val hunks = parseDiffHunks(diff)
        val addedMethods = extractAddedMethods(hunks)
        val modifiedMethods = extractModifiedMethods(hunks)
        val deletedMethods = extractDeletedMethods(hunks)
        
        return FileChange(
            filePath = file.path,
            changeType = file.type,
            addedMethods = addedMethods,
            modifiedMethods = modifiedMethods,
            deletedMethods = deletedMethods,
            hunks = hunks
        )
    }
}
```

### **5.2 Gitæ—¥å¿—æå–å™¨**
```kotlin
class GitLogExtractor {
    
    fun extractCommitHistory(sourceBranch: String, targetBranch: String): CommitContext {
        val commits = executeGitCommand("git log $targetBranch..$sourceBranch --pretty=format:'%H|%an|%ad|%s'")
        
        return CommitContext(
            commits = commits.map { parseCommit(it) },
            totalCommits = commits.size,
            authors = commits.map { it.author }.distinct(),
            businessKeywords = extractBusinessKeywords(commits.map { it.message }),
            intentEvolution = analyzeIntentEvolution(commits)
        )
    }
    
    private fun extractBusinessKeywords(messages: List<String>): List<String> {
        val businessTerms = mutableSetOf<String>()
        
        messages.forEach { message ->
            // æå–å®ä½“åè¯ (User, Order, Productç­‰)
            val entities = extractEntities(message)
            businessTerms.addAll(entities)
            
            // æå–åŠ¨ä½œè¯ (create, update, delete, validateç­‰)
            val actions = extractActions(message)
            businessTerms.addAll(actions)
        }
        
        return businessTerms.toList()
    }
    
    private fun analyzeIntentEvolution(commits: List<Commit>): IntentEvolution {
        // åˆ†ææäº¤æ¶ˆæ¯çš„æ¼”è¿›ï¼Œç†è§£å¼€å‘è€…çš„æ„å›¾å˜åŒ–
        return IntentEvolution(
            initialIntent = inferIntentFromCommit(commits.first()),
            finalIntent = inferIntentFromCommit(commits.last()),
            intentShifts = detectIntentShifts(commits)
        )
    }
}
```

### **5.3 æµ‹è¯•ç”¨ä¾‹å…³è”å™¨**
```kotlin
class TestCaseLinker {
    
    fun linkTestsToBusinessCode(changes: List<FileChange>): TestLinkContext {
        val businessCodeChanges = changes.filter { isBusinessCode(it) }
        val testCodeChanges = changes.filter { isTestCode(it) }
        
        val testCoverage = businessCodeChanges.map { businessChange ->
            val relatedTests = findRelatedTests(businessChange, testCodeChanges)
            TestCoverage(
                businessFile = businessChange.filePath,
                relatedTests = relatedTests,
                coverageType = determineCoverageType(businessChange, relatedTests),
                isSufficient = evaluateTestSufficiency(businessChange, relatedTests)
            )
        }
        
        return TestLinkContext(
            testCoverage = testCoverage,
            overallCoverageRatio = calculateOverallCoverageRatio(testCoverage),
            missingTests = identifyMissingTests(businessCodeChanges, testCoverage)
        )
    }
    
    private fun findRelatedTests(businessChange: FileChange, testChanges: List<FileChange>): List<TestMethod> {
        // åŸºäºå‘½åçº¦å®šæŸ¥æ‰¾
        val conventionBasedTests = findTestsByNamingConvention(businessChange)
        
        // åŸºäºå¯¼å…¥åˆ†ææŸ¥æ‰¾
        val importBasedTests = findTestsByImportAnalysis(businessChange, testChanges)
        
        // åŸºäºè°ƒç”¨å…³ç³»æŸ¥æ‰¾
        val callBasedTests = findTestsByCallGraph(businessChange)
        
        return (conventionBasedTests + importBasedTests + callBasedTests).distinct()
    }
}
```

### **5.4 å®Œæ•´æ–¹æ³•ä½“æå–å™¨**
```kotlin
class MethodBodyExtractor {
    
    fun extractMethodBodies(methodChanges: List<MethodChange>): MethodBodyContext {
        return MethodBodyContext(
            beforeAfterPairs = methodChanges.map { change ->
                when (change.type) {
                    ChangeType.ADDED -> MethodBodyPair(
                        before = null,
                        after = extractCompleteMethodBody(change.method),
                        changeType = change.type
                    )
                    ChangeType.MODIFIED -> MethodBodyPair(
                        before = extractMethodBodyFromCommit(change.method, change.beforeCommit),
                        after = extractCompleteMethodBody(change.method),
                        changeType = change.type
                    )
                    ChangeType.DELETED -> MethodBodyPair(
                        before = extractMethodBodyFromCommit(change.method, change.beforeCommit),
                        after = null,
                        changeType = change.type
                    )
                }
            }
        )
    }
    
    private fun extractCompleteMethodBody(method: MethodNode): MethodBody {
        val psiMethod = findPsiMethod(method)
        
        return MethodBody(
            signature = method.signature,
            body = psiMethod.body?.text ?: "",
            parameters = psiMethod.parameters.map { it.name to it.type.canonicalText },
            returnType = psiMethod.returnType?.canonicalText ?: "void",
            annotations = psiMethod.annotations.map { it.text },
            javadoc = psiMethod.docComment?.text,
            complexity = calculateComplexity(psiMethod),
            dependencies = extractDependencies(psiMethod)
        )
    }
}
```

---

## ğŸ”§ **6. åŒæµæ™ºèƒ½é¢„å¤„ç†å™¨ (æ ¸å¿ƒåˆ›æ–°)**

### **6.1 æ„å›¾æƒé‡è®¡ç®— (è¯¦ç»†ç®—æ³•)**

```kotlin
class IntentWeightCalculator {
    
    fun calculateIntentWeight(path: CallPath, context: AnalysisContext): Double {
        val businessValue = calculateBusinessValue(path, context)
        val completeness = calculateCompleteness(path, context)
        val codeQuality = calculateCodeQuality(path)
        
        return (businessValue * 0.4 + completeness * 0.35 + codeQuality * 0.25)
    }
    
    private fun calculateBusinessValue(path: CallPath, context: AnalysisContext): Double {
        var score = 0.0
        
        // æ–°ç«¯ç‚¹æƒé‡ (+30åˆ†)
        if (path.hasNewEndpoint()) {
            score += 30.0
            // å¦‚æœæ˜¯RESTful APIç«¯ç‚¹ï¼Œé¢å¤–åŠ åˆ†
            if (path.isRESTfulEndpoint()) score += 10.0
        }
        
        // ä¸šåŠ¡åè¯åŒ¹é…åº¦ (0-25åˆ†)
        val businessTermsMatch = calculateBusinessTermsMatch(
            path.getBusinessTerms(), 
            context.commitContext.businessKeywords
        )
        score += businessTermsMatch * 25.0
        
        // DTO/VOå˜æ›´æƒé‡ (+20åˆ†)
        if (path.hasDataModelChanges()) {
            score += 20.0
            // å¦‚æœæ˜¯æ ¸å¿ƒä¸šåŠ¡å®ä½“ï¼Œé¢å¤–åŠ åˆ†
            if (path.isCoreBusinessEntity()) score += 10.0
        }
        
        // æ•°æ®åº“æ“ä½œæƒé‡ (+15åˆ†)
        if (path.hasDatabaseOperations()) {
            score += 15.0
            // å¦‚æœæ¶‰åŠäº‹åŠ¡æ“ä½œï¼Œé¢å¤–åŠ åˆ†
            if (path.hasTransactionalOperations()) score += 5.0
        }
        
        // å¤–éƒ¨APIé›†æˆæƒé‡ (+15åˆ†)
        if (path.hasExternalApiCalls()) score += 15.0
        
        return minOf(score, 100.0)
    }
    
    private fun calculateCompleteness(path: CallPath, context: AnalysisContext): Double {
        var score = 0.0
        
        // å®Œæ•´è°ƒç”¨é“¾æƒé‡ (0-40åˆ†)
        val chainCompleteness = evaluateCallChainCompleteness(path)
        score += chainCompleteness * 40.0
        
        // é”™è¯¯å¤„ç†å®Œæ•´æ€§ (0-30åˆ†)
        val errorHandling = evaluateErrorHandling(path)
        score += errorHandling * 30.0
        
        // æ—¥å¿—è®°å½•å®Œæ•´æ€§ (0-20åˆ†)
        val logging = evaluateLogging(path)
        score += logging * 20.0
        
        // æ–‡æ¡£å®Œæ•´æ€§ (0-10åˆ†)
        val documentation = evaluateDocumentation(path)
        score += documentation * 10.0
        
        return minOf(score, 100.0)
    }
    
    private fun calculateCodeQuality(path: CallPath): Double {
        var score = 100.0 // ä»æ»¡åˆ†å¼€å§‹æ‰£åˆ†
        
        // å¤æ‚åº¦æ‰£åˆ†
        val avgComplexity = path.getAverageComplexity()
        if (avgComplexity > 10) score -= (avgComplexity - 10) * 5.0
        
        // æ–¹æ³•é•¿åº¦æ‰£åˆ†
        val avgMethodLength = path.getAverageMethodLength()
        if (avgMethodLength > 50) score -= (avgMethodLength - 50) * 0.5
        
        // é‡å¤ä»£ç æ‰£åˆ†
        val duplicationRatio = path.getDuplicationRatio()
        score -= duplicationRatio * 30.0
        
        // å‘½åè´¨é‡æ‰£åˆ†
        val namingQuality = path.getNamingQuality()
        score -= (1.0 - namingQuality) * 20.0
        
        return maxOf(score, 0.0)
    }
}
```

### **6.2 é£é™©æƒé‡è®¡ç®— (è¯¦ç»†ç®—æ³•)**

```kotlin
class RiskWeightCalculator {
    
    fun calculateRiskWeight(path: CallPath, context: AnalysisContext): Double {
        val architecturalRisk = calculateArchitecturalRisk(path)
        val blastRadius = calculateBlastRadius(path, context)
        val changeComplexity = calculateChangeComplexity(path)
        
        return (architecturalRisk * 0.4 + blastRadius * 0.35 + changeComplexity * 0.25)
    }
    
    private fun calculateArchitecturalRisk(path: CallPath): Double {
        var risk = 0.0
        
        // è·¨å±‚è°ƒç”¨è¿è§„ (+40åˆ†)
        if (path.hasLayerViolation()) {
            risk += 40.0
            val violationType = path.getLayerViolationType()
            when (violationType) {
                LayerViolationType.CONTROLLER_TO_DAO -> risk += 20.0 // ä¸¥é‡è¿è§„
                LayerViolationType.SERVICE_TO_CONTROLLER -> risk += 10.0 // ä¸­ç­‰è¿è§„
                LayerViolationType.UTIL_TO_SERVICE -> risk += 5.0 // è½»å¾®è¿è§„
            }
        }
        
        // æ•æ„Ÿæ³¨è§£é£é™© (0-30åˆ†)
        val sensitiveAnnotations = path.getSensitiveAnnotations()
        sensitiveAnnotations.forEach { annotation ->
            when (annotation) {
                "@Transactional" -> risk += 10.0
                "@Async" -> risk += 8.0
                "@Scheduled" -> risk += 8.0
                "@Cacheable" -> risk += 5.0
                "@PreAuthorize" -> risk += 12.0 // å®‰å…¨ç›¸å…³
                "@PostAuthorize" -> risk += 12.0
                "@Lock" -> risk += 15.0 // å¹¶å‘ç›¸å…³
            }
        }
        
        // å¾ªç¯ä¾èµ–é£é™© (+50åˆ†)
        if (path.hasCircularDependency()) {
            risk += 50.0
            val circuitLength = path.getCircularDependencyLength()
            if (circuitLength > 3) risk += 10.0 // é•¿å¾ªç¯æ›´å±é™©
        }
        
        // SOLIDåŸåˆ™è¿è§„ (0-25åˆ†)
        val solidViolations = evaluateSOLIDViolations(path)
        risk += solidViolations.size * 5.0
        
        // å¹¶å‘å®‰å…¨é£é™© (0-20åˆ†)
        val concurrencyRisk = evaluateConcurrencyRisk(path)
        risk += concurrencyRisk * 20.0
        
        return minOf(risk, 100.0)
    }
    
    private fun calculateBlastRadius(path: CallPath, context: AnalysisContext): Double {
        // è®¡ç®—è¯¥è·¯å¾„ä¸­æ–¹æ³•è¢«å…¶ä»–æ–¹æ³•è°ƒç”¨çš„æ€»æ¬¡æ•°
        val totalReferences = path.methods.sumOf { method ->
            context.graph.getIncomingEdges(method).size
        }
        
        val totalMethods = context.graph.getMethodCount()
        val referenceRatio = totalReferences.toDouble() / totalMethods
        
        // çˆ†ç‚¸åŠå¾„åŸºç¡€åˆ†æ•°
        var blastRadius = referenceRatio * 60.0
        
        // å…¬å…±å·¥å…·ç±»é¢å¤–æƒé‡
        if (path.hasUtilityMethods()) {
            blastRadius += 20.0
        }
        
        // æ ¸å¿ƒä¸šåŠ¡ç±»é¢å¤–æƒé‡
        if (path.hasCoreBusinessMethods()) {
            blastRadius += 15.0
        }
        
        // æ¥å£å®ç°é¢å¤–æƒé‡
        if (path.hasInterfaceImplementations()) {
            blastRadius += 10.0
        }
        
        return minOf(blastRadius, 100.0)
    }
    
    private fun calculateChangeComplexity(path: CallPath): Double {
        var complexity = 0.0
        
        // å˜æ›´æ–¹æ³•æ•°é‡æƒé‡
        val changedMethodCount = path.getChangedMethodCount()
        complexity += minOf(changedMethodCount * 5.0, 30.0)
        
        // å˜æ›´è¡Œæ•°æƒé‡
        val changedLines = path.getTotalChangedLines()
        complexity += minOf(changedLines * 0.1, 25.0)
        
        // æ–°å¢ä¾èµ–æƒé‡
        val newDependencies = path.getNewDependencies()
        complexity += newDependencies.size * 3.0
        
        // é…ç½®æ–‡ä»¶å˜æ›´æƒé‡
        if (path.hasConfigurationChanges()) {
            complexity += 20.0
        }
        
        // è·¨æ¨¡å—å˜æ›´æƒé‡
        val affectedModules = path.getAffectedModules()
        if (affectedModules.size > 1) {
            complexity += (affectedModules.size - 1) * 8.0
        }
        
        return minOf(complexity, 100.0)
    }
}
```

---

## ğŸ¤– **7. å¤šAIä¾›åº”å•†æ”¯æŒæ¶æ„ (è¯¦ç»†è®¾è®¡)**

### **7.1 AIä¾›åº”å•†é€‚é…å™¨**

```kotlin
interface AIProvider {
    suspend fun analyze(context: AnalysisContext): AnalysisResult
    fun getCapabilities(): AICapabilities
    fun getCostPerToken(): Double
    fun getLatencyEstimate(): Duration
    fun getMaxTokens(): Int
    fun isHealthy(): Boolean
}

// OpenAIé€‚é…å™¨
class OpenAIProvider(private val apiKey: String) : AIProvider {
    private val client = OpenAIClient(apiKey)
    
    override suspend fun analyze(context: AnalysisContext): AnalysisResult {
        val request = buildOpenAIRequest(context)
        val response = client.createChatCompletion(request)
        return parseOpenAIResponse(response)
    }
    
    override fun getCapabilities(): AICapabilities {
        return AICapabilities(
            maxTokens = 128000, // GPT-4o
            supportsCodeAnalysis = true,
            supportsFunctionCalling = true,
            reasoningCapability = ReasoningLevel.ADVANCED,
            costTier = CostTier.HIGH
        )
    }
}

// Anthropicé€‚é…å™¨
class AnthropicProvider(private val apiKey: String) : AIProvider {
    private val client = AnthropicClient(apiKey)
    
    override suspend fun analyze(context: AnalysisContext): AnalysisResult {
        val request = buildClaudeRequest(context)
        val response = client.createMessage(request)
        return parseClaudeResponse(response)
    }
    
    override fun getCapabilities(): AICapabilities {
        return AICapabilities(
            maxTokens = 200000, // Claude-3
            supportsCodeAnalysis = true,
            supportsFunctionCalling = false,
            reasoningCapability = ReasoningLevel.ADVANCED,
            costTier = CostTier.HIGH
        )
    }
}

// Ollamaæœ¬åœ°é€‚é…å™¨
class OllamaProvider(private val baseUrl: String) : AIProvider {
    private val client = OllamaClient(baseUrl)
    
    override suspend fun analyze(context: AnalysisContext): AnalysisResult {
        val request = buildOllamaRequest(context)
        val response = client.generate(request)
        return parseOllamaResponse(response)
    }
    
    override fun getCapabilities(): AICapabilities {
        return AICapabilities(
            maxTokens = 32768, // Llama3
            supportsCodeAnalysis = true,
            supportsFunctionCalling = false,
            reasoningCapability = ReasoningLevel.MODERATE,
            costTier = CostTier.FREE // æœ¬åœ°è¿è¡Œ
        )
    }
}
```

### **7.2 æ™ºèƒ½è·¯ç”±ä¸è´Ÿè½½å‡è¡¡**

```kotlin
class AIOrchestrator {
    
    fun selectOptimalProvider(
        analysisType: AnalysisType,
        complexity: Int,
        budget: Budget,
        urgency: Urgency
    ): AIProvider {
        
        val availableProviders = getHealthyProviders()
        
        return when {
            // é¢„ç®—ä¼˜å…ˆ
            budget == Budget.LOW -> selectCheapestProvider(availableProviders)
            
            // é€Ÿåº¦ä¼˜å…ˆ
            urgency == Urgency.HIGH -> selectFastestProvider(availableProviders)
            
            // è´¨é‡ä¼˜å…ˆ
            analysisType == AnalysisType.DEEP_REVIEW -> selectMostCapableProvider(availableProviders)
            
            // å¤æ‚åº¦é€‚é…
            complexity > 80 -> selectHighCapabilityProvider(availableProviders)
            
            // é»˜è®¤å‡è¡¡é€‰æ‹©
            else -> selectBalancedProvider(availableProviders)
        }
    }
    
    private fun selectMostCapableProvider(providers: List<AIProvider>): AIProvider {
        return providers
            .filter { it.getCapabilities().reasoningCapability == ReasoningLevel.ADVANCED }
            .minByOrNull { it.getLatencyEstimate() }
            ?: providers.first()
    }
    
    private fun selectCheapestProvider(providers: List<AIProvider>): AIProvider {
        return providers.minByOrNull { it.getCostPerToken() } ?: providers.first()
    }
    
    private fun selectFastestProvider(providers: List<AIProvider>): AIProvider {
        return providers.minByOrNull { it.getLatencyEstimate() } ?: providers.first()
    }
}
```

### **7.3 ä¸‰çº§Fallbackæœºåˆ¶**

```kotlin
class FallbackManager {
    
    suspend fun executeWithFallback(
        context: AnalysisContext,
        primaryProvider: AIProvider
    ): AnalysisResult {
        
        return try {
            // Level 1: ä¸»è¦AIä¾›åº”å•†
            primaryProvider.analyze(context)
        } catch (e: APIRateLimitException) {
            // Level 2: åˆ‡æ¢åˆ°å¤‡ç”¨AIä¾›åº”å•†
            val secondaryProvider = getSecondaryProvider(primaryProvider)
            try {
                secondaryProvider.analyze(context)
            } catch (e2: Exception) {
                // Level 3: é™çº§åˆ°è§„åˆ™åŸºç¡€åˆ†æ
                performRuleBasedAnalysis(context)
            }
        } catch (e: NetworkException) {
            // ç½‘ç»œé—®é¢˜ï¼Œç›´æ¥é™çº§åˆ°æœ¬åœ°åˆ†æ
            val localProvider = getLocalProvider()
            if (localProvider.isHealthy()) {
                localProvider.analyze(context)
            } else {
                performRuleBasedAnalysis(context)
            }
        } catch (e: Exception) {
            // å…¶ä»–å¼‚å¸¸ï¼Œè®°å½•å¹¶é™çº§
            logger.error("AI analysis failed: ${e.message}", e)
            performRuleBasedAnalysis(context)
        }
    }
    
    private fun performRuleBasedAnalysis(context: AnalysisContext): AnalysisResult {
        return RuleBasedAnalyzer().analyze(context)
    }
}
```

---

## ğŸ¯ **8. ç»ˆæAI Promptæ¨¡æ¿ (V5.1å®Œæ•´ç‰ˆ)**

### **8.1 é˜¶æ®µä¸€ï¼šå¿«é€Ÿç­›é€‰Prompt**

```text
# Role: Senior Code Reviewer (Quick Screening)

You are performing a rapid initial screening of code changes to identify the most important paths for detailed analysis.

## Input Context
**Project Type**: ${projectType}
**Changed Files**: ${changedFileCount}
**Total Methods Analyzed**: ${totalMethods}
**Commit Messages**: ${commitMessages}

## All Detected Paths
${allDetectedPaths}

## Your Task
Based on the provided paths and their preliminary weights, select:

1. **Top 2 Intent Paths** (Golden Paths): The paths most likely representing the core feature/functionality being implemented
2. **Top 3-5 Risk Paths** (High-Risk Paths): The paths with highest potential for introducing bugs or architectural issues

## Output Format
```json
{
  "golden_paths": [
    {
      "path_id": "path_001",
      "reason": "Main user registration flow with new endpoint",
      "confidence": 0.9
    }
  ],
  "risk_paths": [
    {
      "path_id": "path_003", 
      "reason": "Direct controller to DAO access bypassing service layer",
      "risk_level": "HIGH",
      "confidence": 0.85
    }
  ]
}
```

Be concise and focus on the most critical paths only.
```

### **8.2 é˜¶æ®µäºŒï¼šæ·±åº¦åˆ†æPrompt**

```text
# Role: Senior Software Architect (Deep Analysis)

You are conducting a comprehensive code review for a Merge Request. Your task is to first analyze the developer's intended functionality and its implementation, and then separately analyze the potential risks and negative impacts. Finally, provide a balanced, holistic review.

## Project Context
**Project Type**: ${projectType}
**Branch**: ${sourceBranch} â†’ ${targetBranch}
**Total Changes**: ${changedFiles} files, +${addedLines}/-${deletedLines} lines
**Author(s)**: ${authors}
**Duration**: ${developmentDuration}

# ==========================================
# Part 1: Intent Analysis (The "What")
# ==========================================

## Context for Intent Analysis
The following "Golden Path" has been identified as representing the core feature being implemented:

**Golden Path Details**:
${goldenPathDetails}

**Related Code Changes**:
```diff
${intentRelatedDiffs}
```

**Developer's Stated Intent (Commit Messages)**:
${commitMessages}

**Business Context Extracted**:
- Business Keywords: ${businessKeywords}
- Intent Evolution: ${intentEvolution}

## Your Task for Part 1
Based ONLY on the information for Intent Analysis, please answer:

### 1.1 Functionality Implemented
Describe the business feature or technical functionality the developer has added or changed. Focus on the "what" and "why".

### 1.2 Implementation Summary  
Briefly explain how this functionality was technically realized through the provided code path. Include:
- Key design decisions
- Technology choices
- Integration patterns used

### 1.3 Business Value Assessment
Evaluate the value this change brings:
- **User Impact**: How does this benefit end users?
- **Technical Debt**: Does this reduce or increase technical debt?
- **Maintainability**: How will this affect future development?

# ==========================================
# Part 2: Impact & Risk Analysis (The "How")
# ==========================================

## Context for Risk Analysis
The following "High-Risk Paths" have been identified by pre-analysis:

${riskPathsDetails}

**Test Coverage Analysis**:
${testCoverageAnalysis}

**Dependencies Impact**:
${dependencyImpact}

## Your Task for Part 2
Based ONLY on the risk-related information, please answer:

### 2.1 Potential Bugs & Issues
Identify specific potential bugs, logical errors, or edge cases:
- **Logic Errors**: Flawed conditional logic, null pointer risks, etc.
- **Concurrency Issues**: Race conditions, deadlock risks, thread safety
- **Data Integrity**: Validation gaps, data corruption risks
- **Security Vulnerabilities**: Authentication bypass, data exposure

### 2.2 Architectural Concerns
Point out violations of software architecture principles:
- **Layer Violations**: Cross-layer dependencies, bypassed abstractions
- **SOLID Violations**: Single responsibility, open/closed, etc.
- **Design Pattern Misuse**: Inappropriate or incorrect pattern usage
- **Coupling Issues**: Tight coupling, circular dependencies

### 2.3 Maintenance & Operations Issues
Highlight changes that impact maintainability:
- **Code Complexity**: Overly complex methods, deep nesting
- **Performance Impact**: Potential bottlenecks, resource usage
- **Monitoring Gaps**: Missing logging, error handling
- **Documentation Debt**: Undocumented complex logic

# ==========================================
# Part 3: Holistic Review & Final Verdict
# ==========================================

## Your Task for Part 3
Now, considering your analysis from both Part 1 and Part 2, provide a final, balanced code review.

### 3.1 Overall Summary
Acknowledge the value of the implemented feature while recognizing the identified risks. Be balanced and constructive.

### 3.2 Actionable Recommendations
Provide a prioritized list of concrete suggestions. Link each recommendation back to specific risks from Part 2:

**[ğŸ”´ Critical - Must Fix Before Merge]**:
- Issue: [Specific problem]
- Impact: [Why this is critical]
- Solution: [Concrete fix]
- Location: [File:line reference]

**[ğŸŸ¡ Important - Should Fix Soon]**:
- Issue: [Specific problem]
- Impact: [Potential consequences]
- Solution: [Recommended approach]

**[ğŸŸ¢ Suggestion - Consider for Future]**:
- Opportunity: [Improvement area]
- Benefit: [Expected value]
- Approach: [How to implement]

### 3.3 Test Strategy Recommendations
Based on the identified risks, suggest:
- **Missing Test Cases**: Specific scenarios that need testing
- **Test Types**: Unit, integration, end-to-end requirements
- **Edge Cases**: Boundary conditions to validate

### 3.4 Final Approval Status
Choose one and provide brief reasoning:

- **âœ… Approved - Ready to Merge**: Code meets quality standards with minor or no issues
- **âš ï¸ Approved with Conditions**: Can merge after addressing critical issues listed above  
- **âŒ Requires Rework**: Significant issues need resolution before merge consideration

**Reasoning**: [1-2 sentences explaining your decision]

---

## Output Guidelines
- Be specific and actionable in your recommendations
- Reference exact file locations when possible (use format `file.java:123`)
- Balance criticism with recognition of good practices
- Focus on the most impactful issues first
- Use clear, professional language that helps developers improve
```

### **8.3 ä¸Šä¸‹æ–‡å‹ç¼©ç­–ç•¥**

```kotlin
class ContextCompressor {
    
    fun compressForAI(context: AnalysisContext, maxTokens: Int): CompressedContext {
        val estimatedTokens = estimateTokenCount(context)
        
        return if (estimatedTokens <= maxTokens) {
            // æ— éœ€å‹ç¼©
            CompressedContext(context, CompressionLevel.NONE)
        } else {
            // æ™ºèƒ½å‹ç¼©
            val compressionRatio = maxTokens.toDouble() / estimatedTokens
            when {
                compressionRatio >= 0.8 -> lightCompression(context)
                compressionRatio >= 0.5 -> mediumCompression(context)
                else -> heavyCompression(context)
            }
        }
    }
    
    private fun lightCompression(context: AnalysisContext): CompressedContext {
        return CompressedContext(
            // ç§»é™¤éå…³é”®çš„ä»£ç æ³¨é‡Š
            gitDiff = removeComments(context.gitDiff),
            // ç®€åŒ–æäº¤æ¶ˆæ¯
            commits = summarizeCommits(context.commits),
            // ä¿ç•™å®Œæ•´çš„è·¯å¾„ä¿¡æ¯
            paths = context.paths,
            compressionLevel = CompressionLevel.LIGHT
        )
    }
    
    private fun mediumCompression(context: AnalysisContext): CompressedContext {
        return CompressedContext(
            // åªä¿ç•™å˜æ›´çš„æ ¸å¿ƒæ–¹æ³•
            gitDiff = extractCoreChanges(context.gitDiff),
            // åˆå¹¶ç›¸ä¼¼çš„æäº¤æ¶ˆæ¯
            commits = mergeCommits(context.commits),
            // ä¿ç•™é«˜æƒé‡è·¯å¾„
            paths = filterHighWeightPaths(context.paths),
            compressionLevel = CompressionLevel.MEDIUM
        )
    }
    
    private fun heavyCompression(context: AnalysisContext): CompressedContext {
        return CompressedContext(
            // åªä¿ç•™æ–¹æ³•ç­¾åå’Œå…³é”®å˜æ›´
            gitDiff = extractSignaturesOnly(context.gitDiff),
            // æå–å…³é”®è¯æ‘˜è¦
            commits = extractKeywords(context.commits),
            // åªä¿ç•™æœ€é«˜æƒé‡çš„è·¯å¾„
            paths = selectTopPaths(context.paths, limit = 3),
            compressionLevel = CompressionLevel.HEAVY
        )
    }
}
```

---

## âš¡ **9. å¼‚æ­¥å¤„ç†ä¸æ€§èƒ½ä¼˜åŒ– (è¯¦ç»†å®ç°)**

### **9.1 ä¸‰é˜¶æ®µå¼‚æ­¥æµæ°´çº¿**

```kotlin
class AsyncAnalysisPipeline {
    
    suspend fun analyzeChanges(changes: GitChanges): Flow<AnalysisProgress> = flow {
        
        // é˜¶æ®µ1: å¿«é€Ÿé¢„æ‰«æ (2-5ç§’)
        emit(AnalysisProgress.Started("å¼€å§‹å¿«é€Ÿæ‰«æ..."))
        val quickScanResult = quickScan(changes)
        emit(AnalysisProgress.QuickScanComplete(quickScanResult))
        
        // é˜¶æ®µ2: æ·±åº¦å›¾åˆ†æ (10-30ç§’) 
        emit(AnalysisProgress.DeepAnalysisStarted("åˆ†æè°ƒç”¨å…³ç³»å›¾..."))
        val deepAnalysisResult = async { deepAnalysis(quickScanResult) }
        
        // é˜¶æ®µ3: AIæ™ºèƒ½è¯„å®¡ (30-60ç§’) - å¹¶è¡Œæ‰§è¡Œ
        emit(AnalysisProgress.AIAnalysisStarted("AIæ¨¡å‹åˆ†æä¸­..."))
        val aiReviewResult = async { aiReview(deepAnalysisResult.await()) }
        
        // é˜¶æ®µ4: Neo4jå¯è§†åŒ–åŒæ­¥ (å¼‚æ­¥ï¼Œä¸é˜»å¡ä¸»æµç¨‹)
        launch { syncToNeo4j(deepAnalysisResult.await()) }
        
        val finalResult = aiReviewResult.await()
        emit(AnalysisProgress.Complete(finalResult))
    }
    
    private suspend fun quickScan(changes: GitChanges): QuickScanResult = withContext(Dispatchers.IO) {
        val hotPaths = pathIndexer.findHotPaths(changes)
        val basicRisks = riskDetector.detectBasicRisks(changes)
        val impactedTests = testLinker.findImpactedTests(changes)
        
        QuickScanResult(
            hotPaths = hotPaths,
            basicRisks = basicRisks,
            impactedTests = impactedTests,
            estimatedComplexity = calculateComplexity(changes)
        )
    }
    
    private suspend fun deepAnalysis(scanResult: QuickScanResult): DeepAnalysisResult = withContext(Dispatchers.Default) {
        // å¹¶è¡Œè®¡ç®—æ„å›¾æƒé‡å’Œé£é™©æƒé‡
        val intentWeights = async {
            intentCalculator.calculateWeights(scanResult.hotPaths)
        }
        val riskWeights = async {
            riskCalculator.calculateWeights(scanResult.basicRisks)
        }
        
        val intentPaths = intentAnalyzer.analyze(intentWeights.await())
        val riskPaths = riskAnalyzer.analyze(riskWeights.await())
        
        DeepAnalysisResult(
            goldenPaths = intentPaths.take(2),
            riskPaths = riskPaths.take(5),
            analysisConfidence = calculateConfidence(intentPaths, riskPaths)
        )
    }
    
    private suspend fun aiReview(analysisResult: DeepAnalysisResult): AIReviewResult = withContext(Dispatchers.IO) {
        val context = contextAggregator.buildContext(analysisResult)
        val compressedContext = contextCompressor.compress(context)
        
        return@withContext aiOrchestrator.performReview(compressedContext)
    }
}
```

### **9.2 æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ**

```kotlin
class IntelligentCacheManager {
    
    // L1: å†…å­˜çƒ­ç‚¹ç¼“å­˜ (æœ€è¿‘è®¿é—®çš„æ–¹æ³•å’Œè·¯å¾„)
    private val l1Cache = Caffeine.newBuilder()
        .maximumSize(5000)
        .expireAfterAccess(1, TimeUnit.HOURS)
        .recordStats()
        .build<String, CachedAnalysis>()
    
    // L2: ç£ç›˜æŒä¹…åŒ–ç¼“å­˜ (å®Œæ•´é¡¹ç›®å›¾è°±)
    private val l2Cache = DiskCache(
        directory = Paths.get(System.getProperty("user.home"), ".autocr", "cache"),
        maxSizeBytes = 2L * 1024 * 1024 * 1024 // 2GB
    )
    
    // L3: AIç»“æœç¼“å­˜ (åŸºäºå†…å®¹Hash + æ¨¡å‹ç‰ˆæœ¬)
    private val l3Cache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(24, TimeUnit.HOURS)
        .build<String, AIResult>()
    
    suspend fun getCachedOrAnalyze<T>(
        key: String,
        analyzer: suspend () -> T,
        cacheLevel: CacheLevel = CacheLevel.L1
    ): T {
        return when (cacheLevel) {
            CacheLevel.L1 -> l1Cache.get(key) { analyzer().await() } as T
            CacheLevel.L2 -> getFromL2OrCompute(key, analyzer)
            CacheLevel.L3 -> l3Cache.get(key) { analyzer().await() } as T
        }
    }
    
    private suspend fun getFromL2OrCompute<T>(key: String, analyzer: suspend () -> T): T {
        val cached = l2Cache.get(key)
        return if (cached != null) {
            deserialize(cached)
        } else {
            val result = analyzer()
            l2Cache.put(key, serialize(result))
            result
        }
    }
    
    fun invalidateRelatedCache(changedFiles: List<String>) {
        // æ™ºèƒ½ç¼“å­˜å¤±æ•ˆï¼šåªæ¸…é™¤ä¸å˜æ›´æ–‡ä»¶ç›¸å…³çš„ç¼“å­˜
        val affectedKeys = findAffectedCacheKeys(changedFiles)
        affectedKeys.forEach { key ->
            l1Cache.invalidate(key)
            l2Cache.remove(key)
        }
    }
    
    fun getCacheStatistics(): CacheStatistics {
        val l1Stats = l1Cache.stats()
        return CacheStatistics(
            l1HitRate = l1Stats.hitRate(),
            l1Size = l1Cache.estimatedSize(),
            l2HitRate = l2Cache.getHitRate(),
            l2Size = l2Cache.size(),
            totalMemoryUsage = estimateMemoryUsage()
        )
    }
}
```

### **9.3 å¢é‡æ›´æ–°å¼•æ“**

```kotlin
class IncrementalAnalysisEngine {
    
    fun updateAnalysis(
        baseAnalysis: AnalysisResult,
        changes: List<FileChange>
    ): IncrementalAnalysisResult {
        
        // 1. è¯†åˆ«å—å½±å“çš„èŠ‚ç‚¹å’Œè·¯å¾„
        val affectedNodes = identifyAffectedNodes(changes)
        val affectedPaths = findAffectedPaths(affectedNodes)
        
        // 2. å¢é‡æ›´æ–°å›¾ç»“æ„
        updateGraphStructure(changes)
        
        // 3. é‡æ–°è®¡ç®—å—å½±å“è·¯å¾„çš„æƒé‡
        val updatedWeights = recalculateWeights(affectedPaths)
        
        // 4. åˆå¹¶æ–°æ—§åˆ†æç»“æœ
        val mergedResult = mergeAnalysisResults(baseAnalysis, updatedWeights)
        
        return IncrementalAnalysisResult(
            baseAnalysis = baseAnalysis,
            incrementalChanges = changes,
            affectedPaths = affectedPaths,
            updatedAnalysis = mergedResult,
            processingTime = measureTimeMillis { }
        )
    }
    
    private fun identifyAffectedNodes(changes: List<FileChange>): Set<MethodNode> {
        val directlyAffected = changes.flatMap { change ->
            when (change.type) {
                ChangeType.ADDED -> extractNewMethods(change)
                ChangeType.MODIFIED -> extractModifiedMethods(change)
                ChangeType.DELETED -> extractDeletedMethods(change)
            }
        }.toSet()
        
        // æŸ¥æ‰¾é—´æ¥å—å½±å“çš„èŠ‚ç‚¹ï¼ˆè°ƒç”¨è€…å’Œè¢«è°ƒç”¨è€…ï¼‰
        val indirectlyAffected = directlyAffected.flatMap { node ->
            graph.getConnectedNodes(node, depth = 2)
        }.toSet()
        
        return directlyAffected + indirectlyAffected
    }
    
    private fun updateGraphStructure(changes: List<FileChange>) {
        changes.forEach { change ->
            when (change.type) {
                ChangeType.ADDED -> {
                    val newNodes = extractNewMethods(change)
                    newNodes.forEach { node -> graph.addNode(node) }
                    
                    val newEdges = extractNewCallRelations(change)
                    newEdges.forEach { edge -> graph.addEdge(edge) }
                }
                ChangeType.MODIFIED -> {
                    val modifiedNodes = extractModifiedMethods(change)
                    modifiedNodes.forEach { node -> graph.updateNode(node) }
                    
                    // é‡æ–°åˆ†æè°ƒç”¨å…³ç³»
                    val updatedEdges = reanalyzeCallRelations(change)
                    graph.updateEdges(change.filePath, updatedEdges)
                }
                ChangeType.DELETED -> {
                    val deletedNodes = extractDeletedMethods(change)
                    deletedNodes.forEach { node -> 
                        graph.removeNode(node)
                        graph.removeRelatedEdges(node)
                    }
                }
            }
        }
    }
}
```

---

## ğŸ›¡ï¸ **10. é”™è¯¯å¤„ç†ä¸ç³»ç»Ÿé™çº§ç­–ç•¥**

### **10.1 é”™è¯¯åˆ†ç±»ä½“ç³»**

```kotlin
sealed class AnalysisError(val severity: ErrorSeverity, val recoverable: Boolean) {
    
    // ç½‘ç»œç›¸å…³é”™è¯¯ (å¯æ¢å¤)
    data class NetworkTimeout(val retryCount: Int, val maxRetries: Int) : 
        AnalysisError(ErrorSeverity.MEDIUM, true)
    
    data class APIRateLimit(val provider: String, val resetTime: Instant) : 
        AnalysisError(ErrorSeverity.MEDIUM, true)
    
    data class APIQuotaExceeded(val provider: String, val quotaType: QuotaType) : 
        AnalysisError(ErrorSeverity.HIGH, true)
    
    // AIæœåŠ¡ç›¸å…³é”™è¯¯ (éƒ¨åˆ†å¯æ¢å¤)
    data class ModelUnavailable(val provider: String, val model: String) : 
        AnalysisError(ErrorSeverity.HIGH, true)
    
    data class InvalidAPIResponse(val provider: String, val responseSnippet: String) : 
        AnalysisError(ErrorSeverity.MEDIUM, true)
    
    data class ContextTooLarge(val actualTokens: Int, val maxTokens: Int) : 
        AnalysisError(ErrorSeverity.MEDIUM, true)
    
    // ç³»ç»Ÿç›¸å…³é”™è¯¯ (ä¸å¯æ¢å¤)
    data class InvalidProjectStructure(val reason: String, val missingFiles: List<String>) : 
        AnalysisError(ErrorSeverity.HIGH, false)
    
    data class InsufficientMemory(val requiredMB: Int, val availableMB: Int) : 
        AnalysisError(ErrorSeverity.CRITICAL, false)
    
    data class CorruptedGraphData(val filePath: String, val corruption: String) : 
        AnalysisError(ErrorSeverity.HIGH, false)
    
    data class PSIParsingFailure(val filePath: String, val syntaxError: String) : 
        AnalysisError(ErrorSeverity.MEDIUM, false)
    
    // Gitç›¸å…³é”™è¯¯ (éƒ¨åˆ†å¯æ¢å¤)
    data class GitOperationFailed(val command: String, val exitCode: Int, val stderr: String) : 
        AnalysisError(ErrorSeverity.HIGH, false)
    
    data class BranchNotFound(val branchName: String) : 
        AnalysisError(ErrorSeverity.HIGH, false)
}

enum class ErrorSeverity { LOW, MEDIUM, HIGH, CRITICAL }
```

### **10.2 æ™ºèƒ½é”™è¯¯å¤„ç†å™¨**

```kotlin
class IntelligentErrorHandler {
    
    suspend fun handle(error: AnalysisError, context: ErrorContext): RecoveryAction {
        
        // è®°å½•é”™è¯¯è¯¦æƒ…
        errorLogger.log(error, context)
        
        // æ›´æ–°é”™è¯¯ç»Ÿè®¡
        errorStatistics.record(error)
        
        return when (error) {
            is NetworkTimeout -> handleNetworkTimeout(error, context)
            is APIRateLimit -> handleRateLimit(error, context)
            is ModelUnavailable -> handleModelUnavailable(error, context)
            is ContextTooLarge -> handleContextTooLarge(error, context)
            is InvalidProjectStructure -> handleInvalidProject(error, context)
            is InsufficientMemory -> handleMemoryIssue(error, context)
            is CorruptedGraphData -> handleCorruptedData(error, context)
            is PSIParsingFailure -> handleParsingFailure(error, context)
            is GitOperationFailed -> handleGitFailure(error, context)
            else -> handleGenericError(error, context)
        }
    }
    
    private suspend fun handleNetworkTimeout(
        error: NetworkTimeout, 
        context: ErrorContext
    ): RecoveryAction {
        return if (error.retryCount < error.maxRetries) {
            val delay = calculateBackoffDelay(error.retryCount)
            RecoveryAction.RetryWithDelay(delay)
        } else {
            // é‡è¯•æ¬¡æ•°ç”¨å°½ï¼Œåˆ‡æ¢åˆ°å¤‡ç”¨ä¾›åº”å•†
            val fallbackProvider = findFallbackProvider(context.currentProvider)
            if (fallbackProvider != null) {
                RecoveryAction.SwitchProvider(fallbackProvider)
            } else {
                RecoveryAction.DegradeToOffline()
            }
        }
    }
    
    private suspend fun handleRateLimit(
        error: APIRateLimit, 
        context: ErrorContext
    ): RecoveryAction {
        val waitTime = Duration.between(Instant.now(), error.resetTime)
        
        return if (waitTime < Duration.ofMinutes(5)) {
            // ç­‰å¾…æ—¶é—´è¾ƒçŸ­ï¼Œå»¶è¿Ÿé‡è¯•
            RecoveryAction.RetryAfter(waitTime)
        } else {
            // ç­‰å¾…æ—¶é—´å¤ªé•¿ï¼Œåˆ‡æ¢ä¾›åº”å•†
            val alternativeProvider = findAlternativeProvider(
                excludeProvider = error.provider,
                requiredCapability = context.requiredCapability
            )
            if (alternativeProvider != null) {
                RecoveryAction.SwitchProvider(alternativeProvider)
            } else {
                RecoveryAction.DegradeToRuleBased()
            }
        }
    }
    
    private suspend fun handleContextTooLarge(
        error: ContextTooLarge, 
        context: ErrorContext
    ): RecoveryAction {
        val compressionRatio = error.maxTokens.toDouble() / error.actualTokens
        
        return when {
            compressionRatio >= 0.5 -> {
                // å¯ä»¥é€šè¿‡å‹ç¼©è§£å†³
                RecoveryAction.CompressContext(CompressionLevel.HEAVY)
            }
            compressionRatio >= 0.3 -> {
                // éœ€è¦åˆ†æ®µå¤„ç†
                RecoveryAction.SplitContext(splitCount = 2)
            }
            else -> {
                // ä¸Šä¸‹æ–‡è¿‡å¤§ï¼Œé™çº§åˆ°ç®€åŒ–åˆ†æ
                RecoveryAction.DegradeToSimplified()
            }
        }
    }
    
    private fun calculateBackoffDelay(retryCount: Int): Duration {
        // æŒ‡æ•°é€€é¿ç®—æ³•
        val baseDelay = 1000L // 1ç§’
        val maxDelay = 30000L // 30ç§’
        val delay = minOf(baseDelay * (2.0.pow(retryCount).toLong()), maxDelay)
        
        // æ·»åŠ éšæœºæŠ–åŠ¨ï¼Œé¿å…æƒŠç¾¤æ•ˆåº”
        val jitter = Random.nextLong(0, delay / 4)
        return Duration.ofMillis(delay + jitter)
    }
}
```

### **10.3 ç³»ç»Ÿé™çº§ç®¡ç†å™¨**

```kotlin
class SystemDegradationManager {
    
    private var currentDegradationLevel = DegradationLevel.FULL_SERVICE
    private val degradationHistory = mutableListOf<DegradationEvent>()
    
    fun evaluateAndAdjustDegradation(systemHealth: SystemHealth): DegradationLevel {
        val recommendedLevel = calculateRecommendedDegradation(systemHealth)
        
        if (recommendedLevel != currentDegradationLevel) {
            val event = DegradationEvent(
                from = currentDegradationLevel,
                to = recommendedLevel,
                reason = systemHealth.primaryIssue,
                timestamp = Instant.now()
            )
            
            degradationHistory.add(event)
            currentDegradationLevel = recommendedLevel
            
            // é€šçŸ¥ç”¨æˆ·é™çº§æƒ…å†µ
            notifyDegradation(event)
        }
        
        return currentDegradationLevel
    }
    
    private fun calculateRecommendedDegradation(health: SystemHealth): DegradationLevel {
        return when {
            // AIæœåŠ¡å®Œå…¨ä¸å¯ç”¨
            health.aiServiceAvailability == 0.0 -> DegradationLevel.RULE_BASED_ONLY
            
            // ä¸»è¦AIæœåŠ¡ä¸å¯ç”¨ï¼Œä½†æœ‰å¤‡ç”¨
            health.aiServiceAvailability < 0.3 -> DegradationLevel.LIMITED_AI
            
            // å›¾æœåŠ¡æœ‰é—®é¢˜
            health.graphServiceHealth < 0.5 -> DegradationLevel.BASIC_ANALYSIS
            
            // å†…å­˜ä¸è¶³
            health.memoryUsage > 0.9 -> DegradationLevel.LIGHTWEIGHT_MODE
            
            // ç½‘ç»œé—®é¢˜
            health.networkLatency > Duration.ofSeconds(10) -> DegradationLevel.OFFLINE_MODE
            
            // ä¸€åˆ‡æ­£å¸¸
            else -> DegradationLevel.FULL_SERVICE
        }
    }
    
    fun executeInDegradedMode(
        level: DegradationLevel,
        analysis: () -> AnalysisResult
    ): AnalysisResult {
        return when (level) {
            DegradationLevel.FULL_SERVICE -> analysis()
            
            DegradationLevel.LIMITED_AI -> {
                // åªä½¿ç”¨æœ¬åœ°AIæ¨¡å‹æˆ–æœ€ç®€å•çš„äº‘æ¨¡å‹
                executeWithLimitedAI(analysis)
            }
            
            DegradationLevel.BASIC_ANALYSIS -> {
                // è·³è¿‡å¤æ‚çš„å›¾åˆ†æï¼ŒåªåšåŸºç¡€é™æ€åˆ†æ
                executeBasicAnalysis()
            }
            
            DegradationLevel.RULE_BASED_ONLY -> {
                // å®Œå…¨åŸºäºè§„åˆ™çš„åˆ†æ
                executeRuleBasedAnalysis()
            }
            
            DegradationLevel.LIGHTWEIGHT_MODE -> {
                // å‡å°‘å†…å­˜ä½¿ç”¨ï¼Œç®€åŒ–å¤„ç†
                executeLightweightAnalysis()
            }
            
            DegradationLevel.OFFLINE_MODE -> {
                // çº¯æœ¬åœ°åˆ†æï¼Œä¸ä¾èµ–ç½‘ç»œ
                executeOfflineAnalysis()
            }
        }
    }
}

enum class DegradationLevel(val capabilities: Set<Capability>) {
    FULL_SERVICE(setOf(
        Capability.AI_DEEP_ANALYSIS,
        Capability.GRAPH_ANALYSIS,
        Capability.RISK_DETECTION,
        Capability.INTENT_ANALYSIS,
        Capability.NEO4J_VISUALIZATION
    )),
    
    LIMITED_AI(setOf(
        Capability.AI_BASIC_ANALYSIS,
        Capability.GRAPH_ANALYSIS,
        Capability.RISK_DETECTION,
        Capability.INTENT_ANALYSIS
    )),
    
    BASIC_ANALYSIS(setOf(
        Capability.STATIC_ANALYSIS,
        Capability.RISK_DETECTION,
        Capability.BASIC_METRICS
    )),
    
    RULE_BASED_ONLY(setOf(
        Capability.RULE_BASED_ANALYSIS,
        Capability.BASIC_METRICS
    )),
    
    LIGHTWEIGHT_MODE(setOf(
        Capability.BASIC_DIFF_ANALYSIS,
        Capability.SIMPLE_METRICS
    )),
    
    OFFLINE_MODE(setOf(
        Capability.DIFF_ONLY
    ))
}
```

---

## ğŸ§ª **11. æµ‹è¯•ç­–ç•¥ä¸è´¨é‡è¯„ä¼°æ¡†æ¶**

### **11.1 åŸºå‡†æµ‹è¯•æ•°æ®é›†è®¾è®¡**

```kotlin
data class BenchmarkCase(
    val id: String,
    val name: String,
    val description: String,
    val projectType: ProjectType,
    val complexity: ComplexityLevel,
    val sourceData: BenchmarkSourceData,
    val groundTruth: GroundTruth,
    val metadata: BenchmarkMetadata
)

data class BenchmarkSourceData(
    val gitRepository: String,
    val sourceBranch: String,
    val targetBranch: String,
    val commitRange: String,
    val projectSize: ProjectSize,
    val technologies: List<String>
)

data class GroundTruth(
    val expectedIntents: List<IntentLabel>,
    val expectedRisks: List<RiskLabel>,
    val expertReview: ExpertReview,
    val qualityScore: Double, // 0-100
    val approvalStatus: ApprovalStatus
)

data class IntentLabel(
    val description: String,
    val category: IntentCategory, // FEATURE_ADD, BUG_FIX, REFACTOR, etc.
    val businessValue: Double, // 0-100
    val confidence: Double // 0-1
)

data class RiskLabel(
    val description: String,
    val category: RiskCategory, // ARCHITECTURE, SECURITY, PERFORMANCE, etc.
    val severity: RiskSeverity, // LOW, MEDIUM, HIGH, CRITICAL
    val likelihood: Double, // 0-1
    val impact: Double // 0-100
)

class BenchmarkSuite {
    
    private val testCases = listOf(
        // Spring Boot å¾®æœåŠ¡æ¡ˆä¾‹
        BenchmarkCase(
            id = "sb-user-service-v1",
            name = "Spring Boot User Service Implementation",
            description = "Complete user registration and authentication service with JWT",
            projectType = ProjectType.SPRING_BOOT_MICROSERVICE,
            complexity = ComplexityLevel.MEDIUM,
            sourceData = BenchmarkSourceData(
                gitRepository = "https://github.com/benchmark/spring-user-service",
                sourceBranch = "feature/user-auth",
                targetBranch = "main",
                commitRange = "abc123..def456",
                projectSize = ProjectSize(
                    linesOfCode = 15000,
                    fileCount = 45,
                    methodCount = 180
                ),
                technologies = listOf("Spring Boot", "Spring Security", "JPA", "MySQL")
            ),
            groundTruth = GroundTruth(
                expectedIntents = listOf(
                    IntentLabel(
                        description = "Implement user registration with email validation",
                        category = IntentCategory.FEATURE_ADD,
                        businessValue = 85.0,
                        confidence = 0.95
                    ),
                    IntentLabel(
                        description = "Add JWT-based authentication mechanism", 
                        category = IntentCategory.FEATURE_ADD,
                        businessValue = 90.0,
                        confidence = 0.9
                    )
                ),
                expectedRisks = listOf(
                    RiskLabel(
                        description = "Password stored without proper hashing",
                        category = RiskCategory.SECURITY,
                        severity = RiskSeverity.CRITICAL,
                        likelihood = 0.8,
                        impact = 95.0
                    ),
                    RiskLabel(
                        description = "No rate limiting on registration endpoint",
                        category = RiskCategory.SECURITY,
                        severity = RiskSeverity.MEDIUM,
                        likelihood = 0.6,
                        impact = 60.0
                    )
                ),
                expertReview = ExpertReview(
                    reviewer = "Senior Architect",
                    overallScore = 75.0,
                    criticalIssues = 1,
                    majorIssues = 2,
                    minorIssues = 5,
                    recommendations = listOf(
                        "Add password hashing with bcrypt",
                        "Implement rate limiting",
                        "Add comprehensive logging"
                    )
                ),
                qualityScore = 75.0,
                approvalStatus = ApprovalStatus.REQUIRES_CHANGES
            ),
            metadata = BenchmarkMetadata(
                createdBy = "QA Team",
                createdAt = Instant.parse("2024-01-15T10:00:00Z"),
                lastUpdated = Instant.parse("2024-01-20T15:30:00Z"),
                difficulty = BenchmarkDifficulty.INTERMEDIATE,
                tags = listOf("authentication", "security", "microservice")
            )
        ),
        
        // Androidåº”ç”¨æ¡ˆä¾‹
        BenchmarkCase(
            id = "android-shopping-cart-v1", 
            name = "Android Shopping Cart Feature",
            description = "E-commerce shopping cart with persistence and payment integration",
            projectType = ProjectType.ANDROID_APPLICATION,
            complexity = ComplexityLevel.HIGH,
            // ... æ›´å¤šæ¡ˆä¾‹å®šä¹‰
        ),
        
        // å¼€æºåº“é‡æ„æ¡ˆä¾‹
        BenchmarkCase(
            id = "oss-performance-refactor-v1",
            name = "Open Source Library Performance Refactoring", 
            description = "Large-scale performance optimization in popular Java library",
            projectType = ProjectType.LIBRARY,
            complexity = ComplexityLevel.HIGH,
            // ... æ›´å¤šæ¡ˆä¾‹å®šä¹‰
        )
    )
    
    fun getAllTestCases(): List<BenchmarkCase> = testCases
    
    fun getTestCasesByComplexity(complexity: ComplexityLevel): List<BenchmarkCase> {
        return testCases.filter { it.complexity == complexity }
    }
    
    fun getTestCasesByProjectType(projectType: ProjectType): List<BenchmarkCase> {
        return testCases.filter { it.projectType == projectType }
    }
}
```

### **11.2 å¤šç»´åº¦è´¨é‡è¯„ä¼°å™¨**

```kotlin
class QualityEvaluator {
    
    fun evaluateComprehensive(
        result: AnalysisResult,
        groundTruth: GroundTruth
    ): ComprehensiveQualityMetrics {
        
        val intentMetrics = evaluateIntentDetection(result.intents, groundTruth.expectedIntents)
        val riskMetrics = evaluateRiskDetection(result.risks, groundTruth.expectedRisks)
        val overallMetrics = evaluateOverallQuality(result, groundTruth)
        
        return ComprehensiveQualityMetrics(
            intentDetection = intentMetrics,
            riskDetection = riskMetrics,
            overall = overallMetrics,
            performance = PerformanceMetrics(
                analysisTime = result.processingTime,
                memoryUsage = result.memoryUsed,
                apiCalls = result.apiCallCount,
                cost = result.estimatedCost
            )
        )
    }
    
    private fun evaluateIntentDetection(
        detectedIntents: List<DetectedIntent>,
        expectedIntents: List<IntentLabel>
    ): IntentDetectionMetrics {
        
        val matchedIntents = findMatches(detectedIntents, expectedIntents)
        
        // è®¡ç®—ç²¾ç¡®ç‡ï¼šæ£€æµ‹æ­£ç¡®çš„æ„å›¾ / æ‰€æœ‰æ£€æµ‹åˆ°çš„æ„å›¾
        val precision = matchedIntents.size.toDouble() / detectedIntents.size
        
        // è®¡ç®—å¬å›ç‡ï¼šæ£€æµ‹æ­£ç¡®çš„æ„å›¾ / åº”è¯¥æ£€æµ‹åˆ°çš„æ„å›¾
        val recall = matchedIntents.size.toDouble() / expectedIntents.size
        
        // è®¡ç®—F1åˆ†æ•°
        val f1Score = if (precision + recall > 0) {
            2 * (precision * recall) / (precision + recall)
        } else 0.0
        
        // è®¡ç®—è¯­ä¹‰ç›¸ä¼¼åº¦
        val semanticSimilarity = calculateSemanticSimilarity(detectedIntents, expectedIntents)
        
        return IntentDetectionMetrics(
            precision = precision,
            recall = recall,
            f1Score = f1Score,
            semanticSimilarity = semanticSimilarity,
            totalDetected = detectedIntents.size,
            totalExpected = expectedIntents.size,
            correctMatches = matchedIntents.size
        )
    }
    
    private fun evaluateRiskDetection(
        detectedRisks: List<DetectedRisk>,
        expectedRisks: List<RiskLabel>
    ): RiskDetectionMetrics {
        
        // æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„è¯„ä¼°
        val criticalMetrics = evaluateRisksBySeverity(detectedRisks, expectedRisks, RiskSeverity.CRITICAL)
        val highMetrics = evaluateRisksBySeverity(detectedRisks, expectedRisks, RiskSeverity.HIGH)
        val mediumMetrics = evaluateRisksBySeverity(detectedRisks, expectedRisks, RiskSeverity.MEDIUM)
        val lowMetrics = evaluateRisksBySeverity(detectedRisks, expectedRisks, RiskSeverity.LOW)
        
        // è®¡ç®—åŠ æƒå¹³å‡ï¼ˆä¸¥é‡ç­‰çº§æƒé‡æ›´é«˜ï¼‰
        val weightedPrecision = (
            criticalMetrics.precision * 0.4 +
            highMetrics.precision * 0.3 +
            mediumMetrics.precision * 0.2 +
            lowMetrics.precision * 0.1
        )
        
        val weightedRecall = (
            criticalMetrics.recall * 0.4 +
            highMetrics.recall * 0.3 +
            mediumMetrics.recall * 0.2 +
            lowMetrics.recall * 0.1
        )
        
        return RiskDetectionMetrics(
            overallPrecision = weightedPrecision,
            overallRecall = weightedRecall,
            overallF1Score = 2 * (weightedPrecision * weightedRecall) / (weightedPrecision + weightedRecall),
            bySeverity = mapOf(
                RiskSeverity.CRITICAL to criticalMetrics,
                RiskSeverity.HIGH to highMetrics,
                RiskSeverity.MEDIUM to mediumMetrics,
                RiskSeverity.LOW to lowMetrics
            ),
            falsePositiveRate = calculateFalsePositiveRate(detectedRisks, expectedRisks),
            missedCriticalRisks = countMissedCriticalRisks(detectedRisks, expectedRisks)
        )
    }
    
    private fun calculateSemanticSimilarity(
        detected: List<DetectedIntent>,
        expected: List<IntentLabel>
    ): Double {
        // ä½¿ç”¨è¯å‘é‡æˆ–è¯­ä¹‰åµŒå…¥è®¡ç®—ç›¸ä¼¼åº¦
        // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„å…³é”®è¯åŒ¹é…ç®—æ³•
        val detectedKeywords = detected.flatMap { extractKeywords(it.description) }
        val expectedKeywords = expected.flatMap { extractKeywords(it.description) }
        
        val intersection = detectedKeywords.intersect(expectedKeywords).size
        val union = detectedKeywords.union(expectedKeywords).size
        
        return if (union > 0) intersection.toDouble() / union else 0.0
    }
}
```

### **11.3 A/Bæµ‹è¯•æ¡†æ¶**

```kotlin
class ABTestFramework {
    
    fun runExperiment(
        name: String,
        controlEngine: AnalysisEngine,
        treatmentEngine: AnalysisEngine,
        testCases: List<BenchmarkCase>,
        sampleSize: Int = testCases.size
    ): ExperimentResult {
        
        // éšæœºé€‰æ‹©æµ‹è¯•æ ·æœ¬
        val sampleCases = testCases.shuffled().take(sampleSize)
        
        // å¹¶è¡Œæ‰§è¡Œä¸¤ä¸ªå¼•æ“çš„åˆ†æ
        val controlResults = runParallel(sampleCases) { case ->
            try {
                val result = controlEngine.analyze(case.sourceData)
                EngineResult.Success(case.id, result, "control")
            } catch (e: Exception) {
                EngineResult.Failure(case.id, e, "control")
            }
        }
        
        val treatmentResults = runParallel(sampleCases) { case ->
            try {
                val result = treatmentEngine.analyze(case.sourceData)
                EngineResult.Success(case.id, result, "treatment")
            } catch (e: Exception) {
                EngineResult.Failure(case.id, e, "treatment")
            }
        }
        
        // è¯„ä¼°ç»“æœè´¨é‡
        val controlMetrics = evaluateResults(controlResults, sampleCases)
        val treatmentMetrics = evaluateResults(treatmentResults, sampleCases)
        
        // ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ
        val significance = calculateStatisticalSignificance(controlMetrics, treatmentMetrics)
        
        // æ€§èƒ½å¯¹æ¯”
        val performanceComparison = comparePerformance(controlResults, treatmentResults)
        
        return ExperimentResult(
            experimentName = name,
            sampleSize = sampleSize,
            controlMetrics = controlMetrics,
            treatmentMetrics = treatmentMetrics,
            significance = significance,
            performanceComparison = performanceComparison,
            recommendation = generateRecommendation(controlMetrics, treatmentMetrics, significance),
            executedAt = Instant.now()
        )
    }
    
    private fun calculateStatisticalSignificance(
        control: QualityMetrics,
        treatment: QualityMetrics
    ): StatisticalSignificance {
        
        // ä½¿ç”¨tæ£€éªŒæ¯”è¾ƒä¸¤ç»„ç»“æœçš„å·®å¼‚
        val controlScores = control.detailedScores
        val treatmentScores = treatment.detailedScores
        
        val tStatistic = calculateTStatistic(controlScores, treatmentScores)
        val pValue = calculatePValue(tStatistic, controlScores.size + treatmentScores.size - 2)
        
        val significanceLevel = when {
            pValue < 0.01 -> SignificanceLevel.HIGHLY_SIGNIFICANT
            pValue < 0.05 -> SignificanceLevel.SIGNIFICANT  
            pValue < 0.1 -> SignificanceLevel.MARGINALLY_SIGNIFICANT
            else -> SignificanceLevel.NOT_SIGNIFICANT
        }
        
        return StatisticalSignificance(
            tStatistic = tStatistic,
            pValue = pValue,
            level = significanceLevel,
            confidenceInterval = calculateConfidenceInterval(controlScores, treatmentScores)
        )
    }
    
    private fun generateRecommendation(
        control: QualityMetrics,
        treatment: QualityMetrics,
        significance: StatisticalSignificance
    ): ExperimentRecommendation {
        
        val improvement = treatment.overallScore - control.overallScore
        val performanceChange = treatment.averageAnalysisTime - control.averageAnalysisTime
        val costChange = treatment.averageCost - control.averageCost
        
        return when {
            significance.level == SignificanceLevel.NOT_SIGNIFICANT -> {
                ExperimentRecommendation.NO_CHANGE("No statistically significant difference found")
            }
            
            improvement > 5.0 && performanceChange < Duration.ofSeconds(30) -> {
                ExperimentRecommendation.ADOPT_TREATMENT(
                    "Treatment shows significant quality improvement (+${improvement.format(1)}%) " +
                    "with acceptable performance impact"
                )
            }
            
            improvement > 0 && costChange < 0 -> {
                ExperimentRecommendation.ADOPT_TREATMENT(
                    "Treatment shows improvement with reduced cost"
                )
            }
            
            improvement < -2.0 -> {
                ExperimentRecommendation.KEEP_CONTROL(
                    "Treatment shows quality degradation (-${(-improvement).format(1)}%)"
                )
            }
            
            else -> {
                ExperimentRecommendation.FURTHER_TESTING(
                    "Results are mixed, recommend larger sample size or longer testing period"
                )
            }
        }
    }
}
```

---

## ğŸ“ˆ **12. ä¼ä¸šçº§æˆåŠŸæŒ‡æ ‡ä¸ç›‘æ§**

### **12.1 åˆ†å±‚æ€§èƒ½æŒ‡æ ‡**

```kotlin
data class PerformanceTargets(
    val projectSize: ProjectSize,
    val targets: PerformanceTarget
)

data class PerformanceTarget(
    val maxAnalysisTime: Duration,
    val maxMemoryUsage: Long, // bytes
    val maxCacheSize: Long, // bytes
    val targetCacheHitRate: Double // 0-1
)

class PerformanceMonitor {
    
    private val targets = listOf(
        PerformanceTargets(
            projectSize = ProjectSize.SMALL, // < 50 files, < 50K LoC
            targets = PerformanceTarget(
                maxAnalysisTime = Duration.ofSeconds(15),
                maxMemoryUsage = 256L * 1024 * 1024, // 256MB
                maxCacheSize = 100L * 1024 * 1024, // 100MB
                targetCacheHitRate = 0.6
            )
        ),
        PerformanceTargets(
            projectSize = ProjectSize.MEDIUM, // 50-200 files, 50K-200K LoC
            targets = PerformanceTarget(
                maxAnalysisTime = Duration.ofSeconds(45),
                maxMemoryUsage = 512L * 1024 * 1024, // 512MB
                maxCacheSize = 250L * 1024 * 1024, // 250MB
                targetCacheHitRate = 0.7
            )
        ),
        PerformanceTargets(
            projectSize = ProjectSize.LARGE, // 200-500 files, 200K-500K LoC
            targets = PerformanceTarget(
                maxAnalysisTime = Duration.ofSeconds(90),
                maxMemoryUsage = 1024L * 1024 * 1024, // 1GB
                maxCacheSize = 500L * 1024 * 1024, // 500MB
                targetCacheHitRate = 0.75
            )
        ),
        PerformanceTargets(
            projectSize = ProjectSize.ENTERPRISE, // > 500 files, > 500K LoC
            targets = PerformanceTarget(
                maxAnalysisTime = Duration.ofSeconds(180),
                maxMemoryUsage = 2048L * 1024 * 1024, // 2GB
                maxCacheSize = 1024L * 1024 * 1024, // 1GB
                targetCacheHitRate = 0.8
            )
        )
    )
    
    fun evaluatePerformance(
        projectSize: ProjectSize,
        actualMetrics: ActualPerformanceMetrics
    ): PerformanceEvaluation {
        
        val target = targets.find { it.projectSize == projectSize }?.targets
            ?: targets.last().targets // é»˜è®¤ä½¿ç”¨æœ€é«˜çº§åˆ«æ ‡å‡†
        
        return PerformanceEvaluation(
            analysisTimeScore = calculateScore(actualMetrics.analysisTime, target.maxAnalysisTime),
            memoryUsageScore = calculateScore(actualMetrics.memoryUsage, target.maxMemoryUsage),
            cacheHitRateScore = calculateCacheScore(actualMetrics.cacheHitRate, target.targetCacheHitRate),
            overallScore = calculateOverallPerformanceScore(actualMetrics, target),
            meetsTargets = meetsAllTargets(actualMetrics, target)
        )
    }
    
    private fun calculateScore(actual: Duration, target: Duration): Double {
        val ratio = actual.toMillis().toDouble() / target.toMillis()
        return maxOf(0.0, 100.0 - (ratio - 1.0) * 100.0)
    }
    
    private fun calculateScore(actual: Long, target: Long): Double {
        val ratio = actual.toDouble() / target
        return maxOf(0.0, 100.0 - (ratio - 1.0) * 100.0)
    }
}
```

### **12.2 è´¨é‡ä¿è¯ç›‘æ§**

```kotlin
class QualityAssuranceMonitor {
    
    data class QualityTargets(
        val intentDetectionAccuracy: Double = 0.85, // 85%
        val riskDetectionPrecision: Double = 0.90, // 90%
        val riskDetectionRecall: Double = 0.80, // 80%
        val userAdoptionRate: Double = 0.70, // 70%
        val falsePositiveRate: Double = 0.15, // < 15%
        val criticalRiskMissRate: Double = 0.05 // < 5%
    )
    
    private val targets = QualityTargets()
    
    fun evaluateQuality(metrics: QualityMetrics): QualityEvaluation {
        return QualityEvaluation(
            intentAccuracyScore = calculateQualityScore(
                metrics.intentDetectionAccuracy, 
                targets.intentDetectionAccuracy
            ),
            riskPrecisionScore = calculateQualityScore(
                metrics.riskDetectionPrecision,
                targets.riskDetectionPrecision
            ),
            riskRecallScore = calculateQualityScore(
                metrics.riskDetectionRecall,
                targets.riskDetectionRecall
            ),
            userAdoptionScore = calculateQualityScore(
                metrics.userAdoptionRate,
                targets.userAdoptionRate
            ),
            falsePositiveScore = calculateReverseQualityScore(
                metrics.falsePositiveRate,
                targets.falsePositiveRate
            ),
            criticalRiskMissScore = calculateReverseQualityScore(
                metrics.criticalRiskMissRate,
                targets.criticalRiskMissRate
            ),
            overallQualityScore = calculateOverallQualityScore(metrics),
            meetsQualityStandards = meetsQualityStandards(metrics)
        )
    }
    
    private fun calculateQualityScore(actual: Double, target: Double): Double {
        return minOf(100.0, (actual / target) * 100.0)
    }
    
    private fun calculateReverseQualityScore(actual: Double, target: Double): Double {
        // å¯¹äºè¶Šå°è¶Šå¥½çš„æŒ‡æ ‡ï¼ˆå¦‚è¯¯æŠ¥ç‡ï¼‰
        return if (actual <= target) {
            100.0
        } else {
            maxOf(0.0, 100.0 - ((actual - target) / target) * 100.0)
        }
    }
    
    fun generateQualityReport(
        evaluation: QualityEvaluation,
        historicalData: List<QualityMetrics>
    ): QualityReport {
        
        val trends = analyzeTrends(historicalData)
        val alerts = generateQualityAlerts(evaluation)
        val recommendations = generateQualityRecommendations(evaluation, trends)
        
        return QualityReport(
            currentEvaluation = evaluation,
            trends = trends,
            alerts = alerts,
            recommendations = recommendations,
            generatedAt = Instant.now()
        )
    }
}
```

### **12.3 å¯ç”¨æ€§ä¸ç¨³å®šæ€§ç›‘æ§**

```kotlin
class ReliabilityMonitor {
    
    data class ReliabilityTargets(
        val systemAvailability: Double = 0.995, // 99.5%
        val aiServiceAvailability: Double = 0.990, // 99.0%
        val errorRecoveryTime: Duration = Duration.ofMinutes(2),
        val cacheHitRate: Double = 0.60, // 60%
        val successfulAnalysisRate: Double = 0.98 // 98%
    )
    
    private val targets = ReliabilityTargets()
    private val uptimeTracker = UptimeTracker()
    private val errorTracker = ErrorTracker()
    
    fun recordAnalysisAttempt(result: AnalysisAttemptResult) {
        when (result) {
            is AnalysisAttemptResult.Success -> {
                uptimeTracker.recordSuccess(result.timestamp, result.duration)
            }
            is AnalysisAttemptResult.Failure -> {
                errorTracker.recordError(result.error, result.timestamp)
                uptimeTracker.recordFailure(result.timestamp)
            }
            is AnalysisAttemptResult.Degraded -> {
                uptimeTracker.recordDegradedService(result.timestamp, result.degradationLevel)
            }
        }
    }
    
    fun calculateCurrentReliability(): ReliabilityMetrics {
        val availability = uptimeTracker.calculateAvailability(Duration.ofDays(30))
        val aiServiceHealth = aiServiceMonitor.calculateAvailability(Duration.ofDays(30))
        val errorRate = errorTracker.calculateErrorRate(Duration.ofHours(24))
        val recoveryTime = errorTracker.calculateAverageRecoveryTime(Duration.ofDays(7))
        
        return ReliabilityMetrics(
            systemAvailability = availability,
            aiServiceAvailability = aiServiceHealth,
            errorRate = errorRate,
            averageRecoveryTime = recoveryTime,
            cacheHitRate = cacheManager.getHitRate(),
            successfulAnalysisRate = 1.0 - errorRate
        )
    }
    
    fun generateReliabilityAlerts(metrics: ReliabilityMetrics): List<ReliabilityAlert> {
        val alerts = mutableListOf<ReliabilityAlert>()
        
        if (metrics.systemAvailability < targets.systemAvailability) {
            alerts.add(ReliabilityAlert.LowAvailability(
                current = metrics.systemAvailability,
                target = targets.systemAvailability,
                severity = AlertSeverity.HIGH
            ))
        }
        
        if (metrics.averageRecoveryTime > targets.errorRecoveryTime) {
            alerts.add(ReliabilityAlert.SlowRecovery(
                current = metrics.averageRecoveryTime,
                target = targets.errorRecoveryTime,
                severity = AlertSeverity.MEDIUM
            ))
        }
        
        if (metrics.successfulAnalysisRate < targets.successfulAnalysisRate) {
            alerts.add(ReliabilityAlert.HighFailureRate(
                current = 1.0 - metrics.successfulAnalysisRate,
                target = 1.0 - targets.successfulAnalysisRate,
                severity = AlertSeverity.HIGH
            ))
        }
        
        return alerts
    }
}
```

---

## ğŸ—ºï¸ **13. è¯¦ç»†å®æ–½è·¯çº¿å›¾**

### **Phase 1: åŸºç¡€è®¾æ–½æ­å»º (4-6å‘¨)**

**Week 1-2: æ ¸å¿ƒæ¶æ„**
- âœ… åŒå›¾è°±åŸºç¡€æ¶æ„è®¾è®¡ä¸å®ç°
- âœ… TinkerGraphåµŒå…¥å¼å›¾å¼•æ“é›†æˆ
- âœ… åŸºç¡€ç¼“å­˜ç³»ç»Ÿï¼ˆä¸‰çº§ç¼“å­˜æ¶æ„ï¼‰
- âœ… é¡¹ç›®ç»“æ„åˆå§‹åŒ–å’ŒåŸºç¡€ä¾èµ–ç®¡ç†

**Week 3-4: Gitä¸PSIé›†æˆ**
- âœ… Gitå·®å¼‚åˆ†æå™¨å®Œæ•´å®ç°
- âœ… PSIè§£æå¼•æ“ï¼ˆæ”¯æŒJava/Kotlin/Scalaï¼‰
- âœ… æ–‡ä»¶å˜æ›´æ£€æµ‹å’Œå¢é‡æ›´æ–°æœºåˆ¶
- âœ… åŸºç¡€é”™è¯¯å¤„ç†æ¡†æ¶

**Week 5-6: æ•°æ®æ¨¡å‹ä¸å­˜å‚¨**
- âœ… å®Œæ•´çš„èŠ‚ç‚¹å’Œè¾¹æ•°æ®æ¨¡å‹
- âœ… å›¾æ•°æ®åºåˆ—åŒ–å’ŒæŒä¹…åŒ–
- âœ… å¢é‡æ›´æ–°å¼•æ“
- âœ… æ€§èƒ½åŸºå‡†æµ‹è¯•æ¡†æ¶æ­å»º

### **Phase 2: æ™ºèƒ½åˆ†æå¼•æ“ (6-8å‘¨)**

**Week 7-9: åŒæµé¢„å¤„ç†å™¨**
- âœ… æ„å›¾æƒé‡è®¡ç®—ç®—æ³•å®ç°
- âœ… é£é™©æƒé‡è®¡ç®—ç®—æ³•å®ç°
- âœ… ä¸Šä¸‹æ–‡èšåˆå™¨ï¼ˆGitã€æµ‹è¯•ã€æ–¹æ³•ä½“ï¼‰
- âœ… è·¯å¾„ç­›é€‰å’Œæ’åºç®—æ³•

**Week 10-12: AIæœåŠ¡é›†æˆ**
- âœ… å¤šAIä¾›åº”å•†é€‚é…å™¨ï¼ˆOpenAIã€Anthropicã€Googleã€Ollamaï¼‰
- âœ… æ™ºèƒ½è·¯ç”±å’Œè´Ÿè½½å‡è¡¡
- âœ… ä¸Šä¸‹æ–‡å‹ç¼©å’Œåˆ†æ®µå¤„ç†
- âœ… AI Promptæ¨¡æ¿ç³»ç»Ÿ

**Week 13-14: å¼‚æ­¥å¤„ç†æ¶æ„**
- âœ… ä¸‰é˜¶æ®µå¼‚æ­¥æµæ°´çº¿
- âœ… ä»»åŠ¡é˜Ÿåˆ—å’Œè¿›åº¦è·Ÿè¸ª
- âœ… å¹¶è¡Œå¤„ç†ä¼˜åŒ–
- âœ… å†…å­˜ç®¡ç†å’Œåƒåœ¾å›æ”¶ä¼˜åŒ–

### **Phase 3: ä¼ä¸šçº§åŠŸèƒ½ (4-6å‘¨)**

**Week 15-16: é«˜çº§é”™è¯¯å¤„ç†**
- âœ… ä¸‰çº§Fallbackæœºåˆ¶å®ç°
- âœ… ç³»ç»Ÿé™çº§ç®¡ç†å™¨
- âœ… å¥åº·æ£€æŸ¥å’Œç›‘æ§ç³»ç»Ÿ
- âœ… è‡ªåŠ¨æ¢å¤æœºåˆ¶

**Week 17-18: Neo4jå¯è§†åŒ–é›†æˆ**
- âœ… Neo4jå¼‚æ­¥åŒæ­¥æœåŠ¡
- âœ… é¡¹ç›®å…¨æ™¯å¯è§†åŒ–ç•Œé¢
- âœ… å†å²æ¼”è¿›åˆ†æåŠŸèƒ½
- âœ… å›¢é˜Ÿåä½œæ¨¡å¼åˆ†æ

**Week 19-20: é…ç½®ä¸ç®¡ç†**
- âœ… çµæ´»çš„é…ç½®ç®¡ç†ç³»ç»Ÿ
- âœ… ç”¨æˆ·æƒé™å’Œå®‰å…¨æ§åˆ¶
- âœ… æ’ä»¶è®¾ç½®ç•Œé¢
- âœ… æ—¥å¿—å’Œå®¡è®¡åŠŸèƒ½

### **Phase 4: è´¨é‡ä¿éšœä¸å‘å¸ƒå‡†å¤‡ (3-4å‘¨)**

**Week 21-22: æµ‹è¯•ä¸è´¨é‡**
- âœ… åŸºå‡†æµ‹è¯•æ•°æ®é›†å®Œå–„
- âœ… A/Bæµ‹è¯•æ¡†æ¶å®ç°
- âœ… è‡ªåŠ¨åŒ–è´¨é‡è¯„ä¼°ç³»ç»Ÿ
- âœ… æ€§èƒ½å‹åŠ›æµ‹è¯•

**Week 23-24: å‘å¸ƒå‡†å¤‡**
- âœ… æ–‡æ¡£ç¼–å†™å’Œç”¨æˆ·æŒ‡å—
- âœ… éƒ¨ç½²è„šæœ¬å’ŒCI/CDæµç¨‹
- âœ… å®‰å…¨å®¡è®¡å’Œæ¼æ´æ‰«æ
- âœ… æœ€ç»ˆæ€§èƒ½è°ƒä¼˜

---

## ğŸ† **14. æ€»ç»“ä¸åˆ›æ–°äº®ç‚¹**

### **V5.1ç›¸æ¯”V4.0çš„å®Œæ•´æ”¹è¿›**

**ä¿ç•™V4.0ç²¾å**ï¼š
1. âœ… è¯¦ç»†çš„ç³»ç»Ÿæ¶æ„è®¾è®¡
2. âœ… å®Œæ•´çš„AI Promptæ¨¡æ¿
3. âœ… ç²¾ç¡®çš„æ•°æ®æ¨¡å‹å®šä¹‰
4. âœ… ä¸Šä¸‹æ–‡èšåˆå™¨è®¾è®¡
5. âœ… åŒæµæ™ºèƒ½é¢„å¤„ç†ç†å¿µ

**èåˆV5.0åˆ›æ–°**ï¼š
1. âœ… åŒå›¾è°±æ¶æ„ï¼ˆæœ¬åœ°+Neo4jï¼‰
2. âœ… å¤šAIä¾›åº”å•†æ”¯æŒ
3. âœ… é‡åŒ–æƒé‡è®¡ç®—ç®—æ³•
4. âœ… ä¸‰çº§Fallbackæœºåˆ¶
5. âœ… ä¼ä¸šçº§ç›‘æ§å’Œæµ‹è¯•

### **å…³é”®æŠ€æœ¯åˆ›æ–°**

1. **åŒå›¾è°±æ¶æ„**ï¼šä¸šåŠ¡å¤„ç†ä¸å¯è§†åŒ–åˆ†ç¦»ï¼Œæ€§èƒ½ä¸æ´å¯Ÿå¹¶é‡
2. **æ™ºèƒ½AIç¼–æ’**ï¼šå¤šä¾›åº”å•†æ”¯æŒ+æ™ºèƒ½è·¯ç”±+è‡ªåŠ¨é™çº§
3. **é‡åŒ–è¯„åˆ†ç³»ç»Ÿ**ï¼šé€æ˜çš„ç®—æ³•+å¯è°ƒä¼˜çš„å‚æ•°+å¯è§£é‡Šçš„å†³ç­–
4. **ä¸‰é˜¶æ®µå¼‚æ­¥å¤„ç†**ï¼šå¿«é€Ÿåé¦ˆ+æ·±åº¦åˆ†æ+å¼‚æ­¥å¯è§†åŒ–
5. **ä¼ä¸šçº§å¯é æ€§**ï¼š99.5%å¯ç”¨æ€§+æ™ºèƒ½é”™è¯¯æ¢å¤+å…¨é¢ç›‘æ§

### **ä¼ä¸šç”Ÿäº§å°±ç»ªç‰¹æ€§**

- **é«˜æ€§èƒ½**: å¤§å‹é¡¹ç›®90ç§’å†…å®Œæˆåˆ†æ
- **é«˜å¯ç”¨**: 99.5%ç³»ç»Ÿå¯ç”¨æ€§ä¿éšœ
- **é«˜è´¨é‡**: 85%æ„å›¾è¯†åˆ«å‡†ç¡®ç‡ï¼Œ90%é£é™©æ£€æµ‹ç²¾ç¡®ç‡
- **ä½æˆæœ¬**: å•æ¬¡MRåˆ†ææˆæœ¬<$0.50
- **æ˜“ç»´æŠ¤**: å®Œæ•´çš„ç›‘æ§ã€æ—¥å¿—ã€é…ç½®ç®¡ç†ä½“ç³»

è¿™ä¸ªV5.1æ–¹æ¡ˆæˆåŠŸèåˆäº†V4.0çš„æ·±åº¦è®¾è®¡å’ŒV5.0çš„å·¥ç¨‹ä¼˜åŒ–ï¼Œæ—¢ä¿æŒäº†æŠ€æœ¯å…ˆè¿›æ€§ï¼Œåˆç¡®ä¿äº†ä¼ä¸šçº§çš„ç¨³å®šæ€§å’Œå¯æ‰©å±•æ€§ï¼Œä¸ºå¤§è§„æ¨¡ç”Ÿäº§ç¯å¢ƒçš„éƒ¨ç½²å¥ å®šäº†åšå®åŸºç¡€ã€‚